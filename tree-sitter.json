[{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Syntax Highlighting","text_blocks":["NEWPARAGRAPH\nSyntax highlighting is a very common feature in applications that deal with code. Tree-sitter has built-in support for\nsyntax highlighting via the [`tree-sitter-highlight`][highlight crate] library, which is now used on GitHub.com for highlighting\ncode written in several languages. You can also perform syntax highlighting at the command line using the\n`tree-sitter highlight` command.\nNEWPARAGRAPH\nThis document explains how the Tree-sitter syntax highlighting system works, using the command line interface. If you are\nusing `tree-sitter-highlight` library (either from C or from Rust), all of these concepts are still applicable, but the\nconfiguration data is provided using in-memory objects, rather than files.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Overview","text_blocks":["NEWPARAGRAPH\nAll the files needed to highlight a given language are normally included in the same git repository as the Tree-sitter\ngrammar for that language (for example, [`tree-sitter-javascript`][js grammar], [`tree-sitter-ruby`][ruby grammar]).\nTo run syntax highlighting from the command-line, three types of files are needed:\nNEWPARAGRAPH\n1. Per-user configuration in `~/.config/tree-sitter/config.json` (see the [init-config][init-config] page for more info).\n2. Language configuration in grammar repositories' `tree-sitter.json` files (see the [init][init] page for more info).\n3. Tree queries in the grammars repositories' `queries` folders.\nNEWPARAGRAPH\nFor an example of the language-specific files, see the [`tree-sitter.json` file][ts json] and [`queries` directory][queries]\nin the `tree-sitter-ruby` repository. The following sections describe the behavior of each file.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Language Configuration","text_blocks":["NEWPARAGRAPH\nThe `tree-sitter.json` file is used by the Tree-sitter CLI. Within this file, the CLI looks for data nested under the\ntop-level `\"grammars\"` key. This key is expected to contain an array of objects with the following keys:\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Basics","text_blocks":["NEWPARAGRAPH\nThese keys specify basic information about the parser:\nNEWPARAGRAPH\n- `scope` (required) — A string like `\"source.js\"` that identifies the language. We strive to match the scope names used\nby popular [TextMate grammars][textmate] and by the [Linguist][linguist] library.\nNEWPARAGRAPH\n- `path` (optional) — A relative path from the directory containing `tree-sitter.json` to another directory containing\nthe `src/` folder, which contains the actual generated parser. The default value is `\".\"` (so that `src/` is in the same\nfolder as `tree-sitter.json`), and this very rarely needs to be overridden.\nNEWPARAGRAPH\n- `external-files` (optional) — A list of relative paths from the root dir of a\nparser to files that should be checked for modifications during recompilation.\nThis is useful during development to have changes to other files besides scanner.c\nbe picked up by the cli.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Language Detection","text_blocks":["NEWPARAGRAPH\nThese keys help to decide whether the language applies to a given file:\nNEWPARAGRAPH\n- `file-types` — An array of filename suffix strings. The grammar will be used for files whose names end with one of these\nsuffixes. Note that the suffix may match an *entire* filename.\nNEWPARAGRAPH\n- `first-line-regex` — A regex pattern that will be tested against the first line of a file to determine whether this language\napplies to the file. If present, this regex will be used for any file whose language does not match any grammar's `file-types`.\nNEWPARAGRAPH\n- `content-regex` — A regex pattern that will be tested against the contents of the file to break ties in cases where\nmultiple grammars matched the file using the above two criteria. If the regex matches, this grammar will be preferred over\nanother grammar with no `content-regex`. If the regex does not match, a grammar with no `content-regex` will be preferred\nover this one.\nNEWPARAGRAPH\n- `injection-regex` — A regex pattern that will be tested against a *language name* ito determine whether this language\nshould be used for a potential *language injection* site. Language injection is described in more detail in [a later section]("],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"language-injection).","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Query Paths","text_blocks":["NEWPARAGRAPH\nThese keys specify relative paths from the directory containing `tree-sitter.json` to the files that control syntax highlighting:\nNEWPARAGRAPH\n- `highlights` — Path to a *highlight query*. Default: `queries/highlights.scm`\n- `locals` — Path to a *local variable query*. Default: `queries/locals.scm`.\n- `injections` — Path to an *injection query*. Default: `queries/injections.scm`.\nNEWPARAGRAPH\nThe behaviors of these three files are described in the next section.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Queries","text_blocks":["NEWPARAGRAPH\nTree-sitter's syntax highlighting system is based on *tree queries*, which are a general system for pattern-matching on Tree-sitter's\nsyntax trees. See [this section][pattern matching] of the documentation for more information\nabout tree queries.\nNEWPARAGRAPH\nSyntax highlighting is controlled by *three* different types of query files that are usually included in the `queries` folder.\nThe default names for the query files use the `.scm` file. We chose this extension because it commonly used for files written\nin [Scheme][scheme], a popular dialect of Lisp, and these query files use a Lisp-like syntax.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Highlights","text_blocks":["NEWPARAGRAPH\nThe most important query is called the highlights query. The highlights query uses *captures* to assign arbitrary\n*highlight names* to different nodes in the tree. Each highlight name can then be mapped to a color\n(as described in the [init-config command][theme]). Commonly used highlight names include\n`keyword`, `function`, `type`, `property`, and `string`. Names can also be dot-separated like `function.builtin`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Example Go Snippet","text_blocks":["NEWPARAGRAPH\nFor example, consider the following Go code:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nWith this syntax tree:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\nfunc increment(a int) int {\n    return a + 1\n}\n","\n(source_file\n  (function_declaration\n    name: (identifier)\n    parameters: (parameter_list\n      (parameter_declaration\n        name: (identifier)\n        type: (type_identifier)))\n    result: (type_identifier)\n    body: (block\n      (return_statement\n        (expression_list\n          (binary_expression\n            left: (identifier)\n            right: (int_literal)))))))\n"]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Example Query","text_blocks":["NEWPARAGRAPH\nSuppose we wanted to render this code with the following colors:\nNEWPARAGRAPH\n- keywords `func` and `return` in purple\n- function `increment` in blue\n- type `int` in green\n- number `5` brown\nNEWPARAGRAPH\nWe can assign each of these categories a *highlight name* using a query like this:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThen, in our config file, we could map each of these highlight names to a color:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n; highlights.scm\nNEWPARAGRAPH\n\"func\" @keyword\n\"return\" @keyword\n(type_identifier) @type\n(int_literal) @number\n(function_declaration name: (identifier) @function)\n","\n{\n  \"theme\": {\n    \"keyword\": \"purple\",\n    \"function\": \"blue\",\n    \"type\": \"green\",\n    \"number\": \"brown\"\n  }\n}\n"]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Highlights Result","text_blocks":["NEWPARAGRAPH\nRunning `tree-sitter highlight` on this Go file would produce output like this:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n<pre class='highlight'>\n<span style='color: purple;'>func</span> <span style='color: #005fd7;'>increment</span>(<span>a</span> <span style='color: green;'>int</span>) <span style='color: green;'>int</span> {\n    <span style='color: purple;'>return</span> <span>a</span> <span style='font-weight: bold;color: #4e4e4e;'>+</span> <span style='font-weight: bold;color: #875f00;'>1</span>\n}\n</pre>\n"]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Local Variables","text_blocks":["NEWPARAGRAPH\nGood syntax highlighting helps the reader to quickly distinguish between the different types of *entities* in their code.\nIdeally, if a given entity appears in *multiple* places, it should be colored the same in each place. The Tree-sitter syntax\nhighlighting system can help you to achieve this by keeping track of local scopes and variables.\nNEWPARAGRAPH\nThe *local variables* query is different from the highlights query in that, while the highlights query uses *arbitrary*\ncapture names, which can then be mapped to colors, the locals variable query uses a fixed set of capture names, each of\nwhich has a special meaning.\nNEWPARAGRAPH\nThe capture names are as follows:\nNEWPARAGRAPH\n- `@local.scope` — indicates that a syntax node introduces a new local scope.\n- `@local.definition` — indicates that a syntax node contains the *name* of a definition within the current local scope.\n- `@local.reference` — indicates that a syntax node contains the *name*, which *may* refer to an earlier definition within\nsome enclosing scope.\nNEWPARAGRAPH\nWhen highlighting a file, Tree-sitter will keep track of the set of scopes that contains any given position, and the set\nof definitions within each scope. When processing a syntax node that is captured as a `local.reference`, Tree-sitter will\ntry to find a definition for a name that matches the node's text. If it finds a match, Tree-sitter will ensure that the\n*reference*, and the *definition* are colored the same.\nNEWPARAGRAPH\nThe information produced by this query can also be *used* by the highlights query. You can *disable* a pattern for nodes,\nwhich have been identified as local variables by adding the predicate `("],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"is-not? local)` to the pattern. This is used in","text_blocks":["the example below:\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Example Ruby Snippet","text_blocks":["NEWPARAGRAPH\nConsider this Ruby code:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nWith this syntax tree:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThere are several types of names within this method:\nNEWPARAGRAPH\n- `process_list` is a method.\n- Within this method, `list` is a formal parameter\n- `context` is a local variable.\n- `current_context` is *not* a local variable, so it must be a method.\n- Within the `do` block, `item` is a formal parameter\n- Later on, `item` and `list` are both local variables (not formal parameters).\nNEWPARAGRAPH\n"],"code_blocks":["\ndef process_list(list)\n  context = current_context\n  list.map do |item|\n    process_item(item, context)\n  end\nend\nNEWPARAGRAPH\nitem = 5\nlist = [item]\n","\n(program\n  (method\n    name: (identifier)\n    parameters: (method_parameters\n      (identifier))\n    (assignment\n      left: (identifier)\n      right: (identifier))\n    (method_call\n      method: (call\n        receiver: (identifier)\n        method: (identifier))\n      block: (do_block\n        (block_parameters\n          (identifier))\n        (method_call\n          method: (identifier)\n          arguments: (argument_list\n            (identifier)\n            (identifier))))))\n  (assignment\n    left: (identifier)\n    right: (integer))\n  (assignment\n    left: (identifier)\n    right: (array\n      (identifier))))\n"]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Example Queries","text_blocks":["NEWPARAGRAPH\nLet's write some queries that let us clearly distinguish between these types of names. First, set up the highlighting query,\nas described in the previous section. We'll assign distinct colors to method calls, method definitions, and formal parameters:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThen, we'll set up a local variable query to keep track of the variables and scopes. Here, we're indicating that methods\nand blocks create local *scopes*, parameters and assignments create *definitions*, and other identifiers should be considered\n*references*:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n; highlights.scm\nNEWPARAGRAPH\n(call method: (identifier) @function.method)\n(method_call method: (identifier) @function.method)\nNEWPARAGRAPH\n(method name: (identifier) @function.method)\nNEWPARAGRAPH\n(method_parameters (identifier) @variable.parameter)\n(block_parameters (identifier) @variable.parameter)\nNEWPARAGRAPH\n((identifier) @function.method\n (#is-not? local))\n","\n; locals.scm\nNEWPARAGRAPH\n(method) @local.scope\n(do_block) @local.scope\nNEWPARAGRAPH\n(method_parameters (identifier) @local.definition)\n(block_parameters (identifier) @local.definition)\nNEWPARAGRAPH\n(assignment left:(identifier) @local.definition)\nNEWPARAGRAPH\n(identifier) @local.reference\n"]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Locals Result","text_blocks":["NEWPARAGRAPH\nRunning `tree-sitter highlight` on this ruby file would produce output like this:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n<pre class='highlight'>\n<span style='color: purple;'>def</span> <span style='color: #005fd7;'>process_list</span><span style='color: #4e4e4e;'>(</span><span style='text-decoration: underline;'>list</span><span style='color: #4e4e4e;'>)</span>\n  <span>context</span> <span style='font-weight: bold;color: #4e4e4e;'>=</span> <span style='color: #005fd7;'>current_context</span>\n  <span style='text-decoration: underline;'>list</span><span style='color: #4e4e4e;'>.</span><span style='color: #005fd7;'>map</span> <span style='color: purple;'>do</span> |<span style='text-decoration: underline;'>item</span>|\n    <span style='color: #005fd7;'>process_item</span>(<span style='text-decoration: underline;'>item</span><span style='color: #4e4e4e;'>,</span> <span>context</span><span style='color: #4e4e4e;'>)</span>\n  <span style='color: purple;'>end</span>\n<span style='color: purple;'>end</span>\nNEWPARAGRAPH\n<span>item</span> <span style='font-weight: bold;color: #4e4e4e;'>=</span> <span style='font-weight: bold;color: #875f00;'>5</span>\n<span>list</span> <span style='font-weight: bold;color: #4e4e4e;'>=</span> [<span>item</span><span style='color: #4e4e4e;'>]</span>\n</pre>\n"]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Language Injection","text_blocks":["NEWPARAGRAPH\nSome source files contain code written in multiple different languages. Examples include:\nNEWPARAGRAPH\n- HTML files, which can contain JavaScript inside `<script>` tags and CSS inside `<style>` tags\n- [ERB][erb] files, which contain Ruby inside `<% %>` tags, and HTML outside those tags\n- PHP files, which can contain  HTML between the `<php` tags\n- JavaScript files, which contain regular expression syntax within regex literals\n- Ruby, which can contain snippets of code inside heredoc literals, where the heredoc delimiter often indicates the language\nNEWPARAGRAPH\nAll of these examples can be modeled in terms a *parent* syntax tree and one or more *injected* syntax trees, which reside\n*inside* of certain nodes in the parent tree. The language injection query allows you to specify these \"injections\" using\nthe following captures:\nNEWPARAGRAPH\n- `@injection.content` — indicates that the captured node should have its contents re-parsed using another language.\n- `@injection.language` — indicates that the captured node's text may contain the *name* of a language that should be used\nto re-parse the `@injection.content`.\nNEWPARAGRAPH\nThe language injection behavior can also be configured by some properties associated with patterns:\nNEWPARAGRAPH\n- `injection.language` — can be used to hard-code the name of a specific language.\n- `injection.combined` — indicates that *all* the matching nodes in the tree\n  should have their content parsed as *one* nested document.\n- `injection.include-children` — indicates that the `@injection.content` node's\n  *entire* text should be re-parsed, including the text of its child nodes. By default,\nchild nodes' text will be *excluded* from the injected document.\n- `injection.self` — indicates that the `@injection.content` node should be parsed\n  using the same language as the node itself. This is useful for cases where the\n  node's language is not known until runtime (e.g. via inheriting another language)\n- `injection.parent` indicates that the `@injection.content` node should be parsed\n  using the same language as the node's parent language. This is only meant for injections\n  that need to refer back to the parent language to parse the node's text inside\n  the injected language.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Examples","text_blocks":["NEWPARAGRAPH\nConsider this ruby code:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nWith this syntax tree:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThe following query would specify that the contents of the heredoc should be parsed using a language named \"BASH\"\n(because that is the text of the `heredoc_end` node):\nNEWPARAGRAPH\n","NEWPARAGRAPH\nYou can also force the language using the `"],"code_blocks":["\nsystem <<-BASH.strip!\n  abc --def | ghi > jkl\nBASH\n","\n(program\n  (method_call\n    method: (identifier)\n    arguments: (argument_list\n      (call\n        receiver: (heredoc_beginning)\n        method: (identifier))))\n  (heredoc_body\n    (heredoc_end)))\n","\n(heredoc_body\n  (heredoc_end) @injection.language) @injection.content\n"]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"set!` predicate.","text_blocks":["For example, this will force the language to be always `ruby`.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n((heredoc_body) @injection.content\n (#set! injection.language \"ruby\"))\n"]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"Unit Testing","text_blocks":["NEWPARAGRAPH\nTree-sitter has a built-in way to verify the results of syntax highlighting. The interface is based on [Sublime Text's system][sublime]\nfor testing highlighting.\nNEWPARAGRAPH\nTests are written as normal source code files that contain specially-formatted *comments* that make assertions about the\nsurrounding syntax highlighting. These files are stored in the `test/highlight` directory in a grammar repository.\nNEWPARAGRAPH\nHere is an example of a syntax highlighting test for JavaScript:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n","NEWPARAGRAPH\n[erb]: https://en.wikipedia.org/wiki/ERuby\n[highlight crate]: https://github.com/tree-sitter/tree-sitter/tree/master/highlight\n[init-config]: ./cli/init-config.md\n[init]: ./cli/init.md"],"code_blocks":["\nvar abc = function(d) {\n  // <- keyword\n  //          ^ keyword\n  //               ^ variable.parameter\n  // ^ function\nNEWPARAGRAPH\n  if (a) {\n  // <- keyword\n  // ^ punctuation.bracket\nNEWPARAGRAPH\n    foo(`foo ${bar}`);\n    // <- function\n    //    ^ string\n    //          ^ variable\n  }\nNEWPARAGRAPH\n  baz();\n  // <- !variable\n};\n","\nThe two types of tests are:\nNEWPARAGRAPH\n**Caret**: ^ this will test the following selector against the scope on the most recent non-test line. It will test it\nat the same column the ^ is in. Consecutive ^s will test each column against the selector.\nNEWPARAGRAPH\n**Arrow**: <- this will test the following selector against the scope on the most recent non-test line. It will test it\nat the same column as the comment character is in.\n","\nAn exclamation mark (`!`) can be used to negate a selector. For example, `!keyword` will match any scope that is\nnot the `keyword` class.\n"]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"structure-of-tree-sitterjson","text_blocks":["[js grammar]: https://github.com/tree-sitter/tree-sitter-javascript\n[linguist]: https://github.com/github/linguist\n[pattern matching]: ./using-parsers/queries/index.md\n[queries]: https://github.com/tree-sitter/tree-sitter-ruby/tree/master/queries\n[ruby grammar]: https://github.com/tree-sitter/tree-sitter-ruby\n[scheme]: https://en.wikipedia.org/wiki/Scheme_%28programming_language%29\n[sublime]: https://www.sublimetext.com/docs/3/syntax.html"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"testing","text_blocks":["[textmate]: https://macromates.com/manual/en/language_grammars\n[theme]: ./cli/init-config.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/3-syntax-highlighting.md","header":"theme","text_blocks":["[ts json]: https://github.com/tree-sitter/tree-sitter-ruby/blob/master/tree-sitter.json"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/7-playground.md","header":"</div>","text_blocks":["<div class=\"option\" data-value=\"go\">Go</div>\n    <div class=\"option\" data-value=\"html\">HTML</div>\n    <div class=\"option\" data-value=\"java\">Java</div>\n    <div class=\"option\" data-value=\"javascript\">JavaScript</div>\n    <div class=\"option\" data-value=\"php\">PHP</div>\n    <div class=\"option\" data-value=\"python\">Python</div>\n    <div class=\"option\" data-value=\"ruby\">Ruby</div>\n    <div class=\"option\" data-value=\"rust\">Rust</div>\n    <div class=\"option\" data-value=\"toml\">TOML</div>\n    <div class=\"option\" data-value=\"typescript\">TypeScript</div>\n    <div class=\"option\" data-value=\"yaml\">YAML</div>\n  </div>\n  <select id=\"language-select\" style=\"display: none;\">\n    <option value=\"bash\">Bash</option>\n    <option value=\"c\">C</option>\n    <option value=\"cpp\">C++</option>\n    <option value=\"c_sharp\">C"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/7-playground.md","header":"</option>","text_blocks":["<option value=\"go\">Go</option>\n    <option value=\"html\">HTML</option>\n    <option value=\"java\">Java</option>\n    <option value=\"javascript\" selected=\"selected\">JavaScript</option>\n    <option value=\"php\">PHP</option>\n    <option value=\"python\">Python</option>\n    <option value=\"ruby\">Ruby</option>\n    <option value=\"rust\">Rust</option>\n    <option value=\"toml\">TOML</option>\n    <option value=\"typescript\">TypeScript</option>\n    <option value=\"yaml\">YAML</option>\n  </select>\n</div>\nNEWPARAGRAPH\n<input id=\"logging-checkbox\" type=\"checkbox\"></input>\n<label for=\"logging-checkbox\">Log</label>\nNEWPARAGRAPH\n<input id=\"anonymous-nodes-checkbox\" type=\"checkbox\"></input>\n<label for=\"anonymous-nodes-checkbox\">Show anonymous nodes</label>\nNEWPARAGRAPH\n<input id=\"query-checkbox\" type=\"checkbox\"></input>\n<label for=\"query-checkbox\">Query</label>\nNEWPARAGRAPH\n<input id=\"accessibility-checkbox\" type=\"checkbox\"></input>\n<label for=\"accessibility-checkbox\">Accessibility</label>\nNEWPARAGRAPH\n<textarea id=\"code-input\">\n</textarea>\nNEWPARAGRAPH\n<div id=\"query-container\" style=\"visibility: hidden; position: absolute;\">\n<h2>Query</h2>\n<textarea id=\"query-input\"></textarea>\n</div>\nNEWPARAGRAPH\n<h2>Tree</h2>\n<span id=\"update-time\"></span>\n<div id=\"output-container-scroll\">\n<pre id=\"output-container\" class=\"highlight\"></pre>\n</div>\nNEWPARAGRAPH\n<h2 id=\"about\">About </h2>\n<p>You can try out tree-sitter with a few pre-selected grammars on this page.\nYou can also run playground locally (with your own grammar) using the\n<a href=\"/cli/playground.html\">CLI</a>'s <code>tree-sitter playground</code> subcommand.\n</p>\nNEWPARAGRAPH\n","NEWPARAGRAPH\n<p>The syntax tree should update as you type in the code. As you move around the\ncode, the current node should be highlighted in the tree; you can also click any\nnode in the tree to select the corresponding part of the code.</p>\n<p>You can enter one or more <a href=\"/tree-sitter/using-parsers/queries/index.html\">patterns</a>\ninto the Query panel. If the query is valid, its captures will be\nhighlighted both in the Code and in the Query panels. Otherwise\nthe problematic parts of the query will be underlined, and detailed\ndiagnostics will be available on hover. Note that to see any results\nyou must use at least one capture, like <code>(node_name) @capture-name</code></p>\nNEWPARAGRAPH\n</div>\nNEWPARAGRAPH\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js\"></script>\nNEWPARAGRAPH\n<script>LANGUAGE_BASE_URL = \"https://tree-sitter.github.io\";</script>\n<script type=\"module\">\nimport * as TreeSitter from 'https://tree-sitter.github.io/web-tree-sitter.js';\nwindow.TreeSitter = TreeSitter;\nsetTimeout(() => window.initializePlayground({local: false}), 1);\n</script>\nNEWPARAGRAPH\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/clusterize.js/0.19.0/clusterize.min.js\"></script>"],"code_blocks":["\nLogging (if enabled) can be viewed in the browser's console.\n"]},{"file_path":"tree-sitter/docs/src/SUMMARY.md","header":"Summary","text_blocks":["NEWPARAGRAPH\n[Introduction](./index.md)\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/SUMMARY.md","header":"User Guide","text_blocks":["NEWPARAGRAPH\n- [Using Parsers](./using-parsers/index.md)\n  - [Getting Started](./using-parsers/1-getting-started.md)\n  - [Basic Parsing](./using-parsers/2-basic-parsing.md)\n  - [Advanced Parsing](./using-parsers/3-advanced-parsing.md)\n  - [Walking Trees](./using-parsers/4-walking-trees.md)\n  - [Queries](./using-parsers/queries/index.md)\n    - [Basic Syntax](./using-parsers/queries/1-syntax.md)\n    - [Operators](./using-parsers/queries/2-operators.md)\n    - [Predicates and Directives](./using-parsers/queries/3-predicates-and-directives.md)\n    - [API](./using-parsers/queries/4-api.md)\n  - [Static Node Types](./using-parsers/6-static-node-types.md)\n- [Creating Parsers](./creating-parsers/index.md)\n  - [Getting Started](./creating-parsers/1-getting-started.md)\n  - [The Grammar DSL](./creating-parsers/2-the-grammar-dsl.md)\n  - [Writing the Grammar](./creating-parsers/3-writing-the-grammar.md)\n  - [External Scanners](./creating-parsers/4-external-scanners.md)\n  - [Writing Tests](./creating-parsers/5-writing-tests.md)\n  - [Publishing Parsers](./creating-parsers/6-publishing.md)\n- [Syntax Highlighting](./3-syntax-highlighting.md)\n- [Code Navigation](./4-code-navigation.md)\n- [Implementation](./5-implementation.md)\n- [Contributing](./6-contributing.md)\n- [Playground](./7-playground.md)\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/SUMMARY.md","header":"Reference Guide","text_blocks":["NEWPARAGRAPH\n- [Command Line Interface](./cli/index.md)\n  - [Init Config](./cli/init-config.md)\n  - [Init](./cli/init.md)\n  - [Generate](./cli/generate.md)\n  - [Build](./cli/build.md)\n  - [Parse](./cli/parse.md)\n  - [Test](./cli/test.md)\n  - [Version](./cli/version.md)\n  - [Fuzz](./cli/fuzz.md)\n  - [Query](./cli/query.md)\n  - [Highlight](./cli/highlight.md)\n  - [Tags](./cli/tags.md)\n  - [Playground](./cli/playground.md)\n  - [Dump Languages](./cli/dump-languages.md)\n  - [Complete](./cli/complete.md)"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/6-contributing.md","header":"Contributing","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/6-contributing.md","header":"Code of Conduct","text_blocks":["NEWPARAGRAPH\nContributors to Tree-sitter should abide by the [Contributor Covenant][covenant].\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/6-contributing.md","header":"Developing Tree-sitter","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/6-contributing.md","header":"Prerequisites","text_blocks":["NEWPARAGRAPH\nTo make changes to Tree-sitter, you should have:\nNEWPARAGRAPH\n1. A C compiler, for compiling the core library and the generated parsers.\n2. A [Rust toolchain][rust], for compiling the Rust bindings, the highlighting library, and the CLI.\n3. Node.js and NPM, for generating parsers from `grammar.js` files.\n4. Either [Emscripten][emscripten], [Docker][docker], or [podman][podman] for\ncompiling the library to WASM.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/6-contributing.md","header":"Building","text_blocks":["NEWPARAGRAPH\nClone the repository:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nOptionally, build the WASM library. If you skip this step, then the `tree-sitter playground` command will require an internet\nconnection. If you have Emscripten installed, this will use your `emcc` compiler. Otherwise, it will use Docker or Podman:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nBuild the Rust libraries and the CLI:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis will create the `tree-sitter` CLI executable in the `target/release` folder.\nNEWPARAGRAPH\nIf you want to automatically install the `tree-sitter` CLI in your system, you can run:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nIf you're going to be in a fast iteration cycle and would like the CLI to build faster, you can use the `release-dev` profile:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\ngit clone https://github.com/tree-sitter/tree-sitter\ncd tree-sitter\n","\ncd lib/binding_web\nnpm install # or your JS package manager of choice\nnpm run build\n","\ncargo build --release\n","\ncargo install --path cli\n","\ncargo build --release --profile release-dev\n# or\ncargo install --path cli --profile release-dev\n"]},{"file_path":"tree-sitter/docs/src/6-contributing.md","header":"Testing","text_blocks":["NEWPARAGRAPH\nBefore you can run the tests, you need to fetch some upstream grammars that are used for testing:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nTo test any changes you've made to the CLI, you can regenerate these parsers using your current CLI code:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThen you can run the tests:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nSimilarly, to test the WASM binding, you need to compile these parsers to WASM:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\ncargo xtask fetch-fixtures\n","\ncargo xtask generate-fixtures\n","\ncargo xtask test\n","\ncargo xtask generate-fixtures --wasm\ncargo xtask test-wasm\n"]},{"file_path":"tree-sitter/docs/src/6-contributing.md","header":"Debugging","text_blocks":["NEWPARAGRAPH\nThe test script has a number of useful flags. You can list them all by running `cargo xtask test -h`.\nHere are some of the main flags:\nNEWPARAGRAPH\nIf you want to run a specific unit test, pass its name (or part of its name) as an argument:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nYou can run the tests under the debugger (either `lldb` or `gdb`) using the `-g` flag:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nPart of the Tree-sitter test suite involves parsing the _corpus_ tests for several languages and performing randomized edits\nto each example in the corpus. If you just want to run the tests for a particular _language_, you can pass the `-l` flag.\nAdditionally, if you want to run a particular _example_ from the corpus, you can pass the `-e` flag:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\ncargo xtask test test_does_something\n","\ncargo xtask test -g test_does_something\n","\ncargo xtask test -l javascript -e Arrays\n"]},{"file_path":"tree-sitter/docs/src/6-contributing.md","header":"Published Packages","text_blocks":["NEWPARAGRAPH\nThe main [`tree-sitter/tree-sitter`][ts repo] repository contains the source code for\nseveral packages that are published to package registries for different languages:\nNEWPARAGRAPH\n* Rust crates on [crates.io][crates]:\n  * [`tree-sitter`][lib crate] — A Rust binding to the core library\n  * [`tree-sitter-highlight`][highlight crate] — The syntax-highlighting library\n  * [`tree-sitter-cli`][cli crate] — The command-line tool\nNEWPARAGRAPH\n* JavaScript modules on [npmjs.com][npmjs]:\n  * [`web-tree-sitter`][web-ts] — A WASM-based JavaScript binding to the core library\n  * [`tree-sitter-cli`][cli package] — The command-line tool\nNEWPARAGRAPH\nThere are also several other dependent repositories that contain other published packages:\nNEWPARAGRAPH\n* [`tree-sitter/node-tree-sitter`][node ts] — Node.js bindings to the core library,\npublished as [`tree-sitter`][node package] on npmjs.com\n* [`tree-sitter/py-tree-sitter`][py ts] — Python bindings to the core library,\npublished as [`tree-sitter`][py package] on [PyPI.org][pypi].\n* [`tree-sitter/go-tree-sitter`][go ts] — Go bindings to the core library,\npublished as [`tree_sitter`][go package] on [pkg.go.dev][go.dev].\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/6-contributing.md","header":"Developing Documentation","text_blocks":["NEWPARAGRAPH\nOur current static site generator for documentation is [`mdBook`][mdBook], with a little bit of custom JavaScript to handle\nthe playground page. Most of the documentation is written in Markdown, including this file! You can find these files\nat [`docs/src`][docs src]. If you'd like to submit a PR to improve the documentation, navigate to the page you'd like to\nedit and hit the edit icon at the top right of the page.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/6-contributing.md","header":"Prerequisites for Local Development","text_blocks":["NEWPARAGRAPH\n","NEWPARAGRAPH\nTo run and iterate on the docs locally, the\n[`mdbook`][mdbook cli] CLI tool is required, which can be installed with\nNEWPARAGRAPH\n","NEWPARAGRAPH\nYou might have noticed we have some fancy admonitions sprinkled throughout the documentation, like the note above.\nThese are created using [`mdbook-admonish`][admonish], a [preprocessor][preprocessor] for `mdBook`. As such, this is also\na requirement for developing the documentation locally. To install it, run:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nOnce you've installed it, you can begin using admonitions in your markdown files. See the [reference][admonish reference]\nfor more information.\nNEWPARAGRAPH\n"],"code_blocks":["\nWe're assuming you have `cargo` installed, the Rust package manager.\n","\ncargo install mdbook\n","\ncargo install mdbook-admonish\n"]},{"file_path":"tree-sitter/docs/src/6-contributing.md","header":"Spinning it up","text_blocks":["NEWPARAGRAPH\nNow that you've installed the prerequisites, you can run the following command to start a local server:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n`mdbook` has a live-reload feature, so any changes you make to the markdown files will be reflected in the browser after\na short delay. Once you've made a change that you're happy with, you can submit a PR with your changes.\nNEWPARAGRAPH\n"],"code_blocks":["\ncd docs\nmdbook serve --open\n"]},{"file_path":"tree-sitter/docs/src/6-contributing.md","header":"Improving the Playground","text_blocks":["NEWPARAGRAPH\nThe playground page is a little more complicated, but if you know some basic JavaScript and CSS you should be able to make\nchanges. The playground code can be found in [`docs/src/assets/js/playground.js`][playground], and its corresponding css\nat [`docs/src/assets/css/playground.css`][playground css]. The editor of choice we use for the playground is [CodeMirror][codemirror],\nand the tree-sitter module is fetched from [here][js url]. This, along with the wasm module and wasm parsers, live in the\n[.github.io repo][gh.io repo].\nNEWPARAGRAPH\n[admonish]: https://github.com/tommilligan/mdbook-admonish\n[admonish reference]: https://tommilligan.github.io/mdbook-admonish/reference.html\n[cli crate]: https://crates.io/crates/tree-sitter-cli\n[cli package]: https://www.npmjs.com/package/tree-sitter-cli\n[codemirror]: https://codemirror.net\n[covenant]: https://www.contributor-covenant.org/version/1/4/code-of-conduct\n[crates]: https://crates.io\n[docker]: https://www.docker.com\n[docs src]: https://github.com/tree-sitter/tree-sitter/tree/master/docs/src\n[emscripten]: https://emscripten.org\n[gh.io repo]: https://github.com/tree-sitter/tree-sitter.github.io\n[go.dev]: https://pkg.go.dev\n[go package]: https://pkg.go.dev/github.com/tree-sitter/go-tree-sitter\n[go ts]: https://github.com/tree-sitter/go-tree-sitter\n[highlight crate]: https://crates.io/crates/tree-sitter-highlight\n[js url]: https://tree-sitter.github.io/web-tree-sitter.js\n[lib crate]: https://crates.io/crates/tree-sitter\n[mdBook]: https://rust-lang.github.io/mdBook\n[mdbook cli]: https://rust-lang.github.io/mdBook/guide/installation.html\n[node package]: https://www.npmjs.com/package/tree-sitter\n[node ts]: https://github.com/tree-sitter/node-tree-sitter\n[npmjs]: https://npmjs.com\n[playground]: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/assets/js/playground.js\n[playground css]: https://github.com/tree-sitter/tree-sitter/blob/master/docs/src/assets/css/playground.css\n[podman]: https://podman.io\n[preprocessor]: https://rust-lang.github.io/mdBook/for_developers/preprocessors.html\n[py package]: https://pypi.org/project/tree-sitter\n[py ts]: https://github.com/tree-sitter/py-tree-sitter\n[pypi]: https://pypi.org\n[rust]: https://rustup.rs\n[ts repo]: https://github.com/tree-sitter/tree-sitter\n[web-ts]: https://www.npmjs.com/package/web-tree-sitter"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/5-implementation.md","header":"Implementation","text_blocks":["NEWPARAGRAPH\nTree-sitter consists of two components: a C library (`libtree-sitter`), and a command-line tool (the `tree-sitter` CLI).\nNEWPARAGRAPH\nThe library, `libtree-sitter`, is used in combination with the parsers\ngenerated by the CLI, to produce syntax trees from source code and keep the\nsyntax trees up-to-date as the source code changes. `libtree-sitter` is designed to be embedded in applications. It is\nwritten in plain C. Its interface is specified in the header file [`tree_sitter/api.h`][api.h].\nNEWPARAGRAPH\nThe CLI is used to generate a parser for a language by supplying a [context-free grammar][cfg] describing the\nlanguage. The CLI is a build tool; it is no longer needed once a parser has been generated. It is written in Rust, and is\navailable on [crates.io][crates], [npm][npm], and as a pre-built binary [on GitHub][gh].\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/5-implementation.md","header":"The CLI","text_blocks":["NEWPARAGRAPH\nThe `tree-sitter` CLI's most important feature is the `generate` command. This subcommand reads in a context-free grammar\nfrom a file called `grammar.js` and outputs a parser as a C file called `parser.c`. The source files in the [`cli/src`][src]\ndirectory all play a role in producing the code in `parser.c`. This section will describe some key parts of this process.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/5-implementation.md","header":"Parsing a Grammar","text_blocks":["NEWPARAGRAPH\nFirst, Tree-sitter must evaluate the JavaScript code in `grammar.js` and convert the grammar to a JSON format. It does this\nby shelling out to `node`. The format of the grammars is formally specified by the JSON schema in [grammar.schema.json][schema].\nThe parsing is implemented in [parse_grammar.rs][parse grammar].\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/5-implementation.md","header":"Grammar Rules","text_blocks":["NEWPARAGRAPH\nA Tree-sitter grammar is composed of a set of *rules* — objects that describe how syntax nodes can be composed of other\nsyntax nodes. There are several types of rules: symbols, strings, regexes, sequences, choices, repetitions, and a few others.\nInternally, these are all represented using an [enum][enum] called [`Rule`][rules.rs].\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/5-implementation.md","header":"Preparing a Grammar","text_blocks":["NEWPARAGRAPH\nOnce a grammar has been parsed, it must be transformed in several ways before it can be used to generate a parser. Each\ntransformation is implemented by a separate file in the [`prepare_grammar`][prepare grammar] directory, and the transformations\nare ultimately composed together in `prepare_grammar/mod.rs`.\nNEWPARAGRAPH\nAt the end of these transformations, the initial grammar is split into two grammars: a *syntax grammar* and a *lexical grammar*.\nThe syntax grammar describes how the language's [*non-terminal symbols*][symbols] are constructed from other grammar symbols,\nand the lexical grammar describes how the grammar's *terminal symbols* (strings and regexes) can be\ncomposed of individual characters.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/5-implementation.md","header":"Building Parse Tables","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/5-implementation.md","header":"The Runtime","text_blocks":["NEWPARAGRAPH\nWIP\nNEWPARAGRAPH\n[api.h]: https://github.com/tree-sitter/tree-sitter/blob/master/lib/include/tree_sitter/api.h\n[cfg]: https://en.wikipedia.org/wiki/Context-free_grammar\n[crates]: https://crates.io\n[npm]: https://npmjs.com\n[gh]: https://github.com/tree-sitter/tree-sitter/releases/latest\n[src]: https://github.com/tree-sitter/tree-sitter/tree/master/cli/src\n[schema]: https://tree-sitter.github.io/tree-sitter/assets/schemas/grammar.schema.json\n[parse grammar]: https://github.com/tree-sitter/tree-sitter/blob/master/cli/generate/src/parse_grammar.rs\n[enum]: https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html\n[rules.rs]: https://github.com/tree-sitter/tree-sitter/blob/master/cli/generate/src/rules.rs\n[prepare grammar]: https://github.com/tree-sitter/tree-sitter/tree/master/cli/generate/src/prepare_grammar\n[symbols]: https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/4-code-navigation.md","header":"Code Navigation Systems","text_blocks":["NEWPARAGRAPH\nTree-sitter can be used in conjunction with its [query language][query language] as a part of code navigation systems.\nAn example of such a system can be seen in the `tree-sitter tags` command, which emits a textual dump of the interesting\nsyntactic nodes in its file argument. A notable application of this is GitHub's support for [search-based code navigation][gh search].\nThis document exists to describe how to integrate with such systems, and how to extend this functionality to any language with a Tree-sitter grammar.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/4-code-navigation.md","header":"Tagging and captures","text_blocks":["NEWPARAGRAPH\n_Tagging_ is the act of identifying the entities that can be named in a program. We use Tree-sitter queries to find those\nentities. Having found them, you use a syntax capture to label the entity and its name.\nNEWPARAGRAPH\nThe essence of a given tag lies in two pieces of data: the _role_ of the entity that is matched\n(i.e. whether it is a definition or a reference) and the _kind_ of that entity, which describes how the entity is used\n(i.e. whether it's a class definition, function call, variable reference, and so on). Our convention is to use a syntax capture\nfollowing the `@role.kind` capture name format, and another inner capture, always called `@name`, that pulls out the name\nof a given identifier.\nNEWPARAGRAPH\nYou may optionally include a capture named `@doc` to bind a docstring. For convenience purposes, the tagging system provides\ntwo built-in functions, `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/4-code-navigation.md","header":"select-adjacent!` and `#strip!` that are convenient for removing comment syntax from a docstring.","text_blocks":["`"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/4-code-navigation.md","header":"strip!` takes a capture as its first argument and a regular expression as its second, expressed as a quoted string.","text_blocks":["Any text patterns matched by the regular expression will be removed from the text associated with the passed capture.\n`"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/4-code-navigation.md","header":"select-adjacent!`, when passed two capture names, filters the text associated with the first capture so that only nodes","text_blocks":["adjacent to the second capture are preserved. This can be useful when writing queries that would otherwise include too much\ninformation in matched comments.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/4-code-navigation.md","header":"Examples","text_blocks":["NEWPARAGRAPH\nThis [query][query] recognizes Python function definitions and captures their declared name. The `function_definition`\nsyntax node is defined in the [Python Tree-sitter grammar][node].\nNEWPARAGRAPH\n","NEWPARAGRAPH\nA more sophisticated query can be found in the [JavaScript Tree-sitter repository][js query]:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nAn even more sophisticated query is in the [Ruby Tree-sitter repository][ruby query], which uses built-in functions to\nstrip the Ruby comment character (`"],"code_blocks":["\n(function_definition\n  name: (identifier) @name) @definition.function\n","\n(assignment_expression\n  left: [\n    (identifier) @name\n    (member_expression\n      property: (property_identifier) @name)\n  ]\n  right: [(arrow_function) (function)]\n) @definition.function\n"]},{"file_path":"tree-sitter/docs/src/4-code-navigation.md","header":"`) from the docstrings associated with a class or singleton-class declaration, then","text_blocks":["selects only the docstrings adjacent to the node matched as `@definition.class`.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThe below table describes a standard vocabulary for kinds and roles during the tagging process. New applications may extend\n(or only recognize a subset of) these capture names, but it is desirable to standardize on the names below.\nNEWPARAGRAPH\n| Category                 | Tag                         |\n| ------------------------ | --------------------------- |\n| Class definitions        | `@definition.class`         |\n| Function definitions     | `@definition.function`      |\n| Interface definitions    | `@definition.interface`     |\n| Method definitions       | `@definition.method`        |\n| Module definitions       | `@definition.module`        |\n| Function/method calls    | `@reference.call`           |\n| Class reference          | `@reference.class`          |\n| Interface implementation | `@reference.implementation` |\nNEWPARAGRAPH\n"],"code_blocks":["\n(\n  (comment)* @doc\n  .\n  [\n    (class\n      name: [\n        (constant) @name\n        (scope_resolution\n          name: (_) @name)\n      ]) @definition.class\n    (singleton_class\n      value: [\n        (constant) @name\n        (scope_resolution\n          name: (_) @name)\n      ]) @definition.class\n  ]\n  (#strip! @doc \"^#\\\\s*\")\n  (#select-adjacent! @doc @definition.class)\n)\n"]},{"file_path":"tree-sitter/docs/src/4-code-navigation.md","header":"Command-line invocation","text_blocks":["NEWPARAGRAPH\nYou can use the `tree-sitter tags` command to test out a tags query file, passing as arguments one or more files to tag.\nWe can run this tool from within the Tree-sitter Ruby repository, over code in a file called `test.rb`:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nInvoking `tree-sitter tags test.rb` produces the following console output, representing matched entities' name, role, location,\nfirst line, and docstring:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nIt is expected that tag queries for a given language are located at `queries/tags.scm` in that language's repository.\nNEWPARAGRAPH\n"],"code_blocks":["\nmodule Foo\n  class Bar\n    # won't be included\nNEWPARAGRAPH\n    # is adjacent, will be\n    def baz\n    end\n  end\nend\n","\n    test.rb\n        Foo              | module       def (0, 7) - (0, 10) `module Foo`\n        Bar              | class        def (1, 8) - (1, 11) `class Bar`\n        baz              | method       def (2, 8) - (2, 11) `def baz`  \"is adjacent, will be\"\n"]},{"file_path":"tree-sitter/docs/src/4-code-navigation.md","header":"Unit Testing","text_blocks":["NEWPARAGRAPH\nTags queries may be tested with `tree-sitter test`. Files under `test/tags/` are checked using the same comment system as\n[highlights queries][unit testing]. For example, the above Ruby tags can be tested with these comments:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n[gh search]: https://docs.github.com/en/repositories/working-with-files/using-files/navigating-code-on-github"],"code_blocks":["\nmodule Foo\n  #     ^ definition.module\n  class Bar\n    #    ^ definition.class\nNEWPARAGRAPH\n    def baz\n      #  ^ definition.method\n    end\n  end\nend\n"]},{"file_path":"tree-sitter/docs/src/4-code-navigation.md","header":"precise-and-search-based-navigation","text_blocks":["[js query]: https://github.com/tree-sitter/tree-sitter-javascript/blob/fdeb68ac8d2bd5a78b943528bb68ceda3aade2eb/queries/tags.scm"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/4-code-navigation.md","header":"L63-L70","text_blocks":["[node]: https://github.com/tree-sitter/tree-sitter-python/blob/78c4e9b6b2f08e1be23b541ffced47b15e2972ad/grammar.js"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/4-code-navigation.md","header":"L354","text_blocks":["[query]: https://github.com/tree-sitter/tree-sitter-python/blob/78c4e9b6b2f08e1be23b541ffced47b15e2972ad/queries/tags.scm"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/4-code-navigation.md","header":"L4-L5","text_blocks":["[ruby query]: https://github.com/tree-sitter/tree-sitter-ruby/blob/1ebfdb288842dae5a9233e2509a135949023dd82/queries/tags.scm"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/4-code-navigation.md","header":"L24-L43","text_blocks":["[query language]: ./using-parsers/queries/index.md\n[unit testing]: ./3-syntax-highlighting.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/4-code-navigation.md","header":"unit-testing","text_blocks":[],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/6-static-node-types.md","header":"Static Node Types","text_blocks":["NEWPARAGRAPH\nIn languages with static typing, it can be helpful for syntax trees to provide specific type information about individual\nsyntax nodes. Tree-sitter makes this information available via a generated file called `node-types.json`. This _node types_\nfile provides structured data about every possible syntax node in a grammar.\nNEWPARAGRAPH\nYou can use this data to generate type declarations in statically-typed programming languages.\nNEWPARAGRAPH\nThe node types file contains an array of objects, each of which describes a particular type of syntax node using the\nfollowing entries:\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/6-static-node-types.md","header":"Basic Info","text_blocks":["NEWPARAGRAPH\nEvery object in this array has these two entries:\nNEWPARAGRAPH\n- `\"type\"` — A string that indicates, which grammar rule the node represents. This corresponds to the `ts_node_type` function\ndescribed [here][syntax nodes].\n- `\"named\"` — A boolean that indicates whether this kind of node corresponds to a rule name in the grammar or just a string\nliteral. See [here][named-vs-anonymous-nodes] for more info.\nNEWPARAGRAPH\nExamples:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nTogether, these two fields constitute a unique identifier for a node type; no two top-level objects in the `node-types.json`\nshould have the same values for both `\"type\"` and `\"named\"`.\nNEWPARAGRAPH\n"],"code_blocks":["\n{\n  \"type\": \"string_literal\",\n  \"named\": true\n}\n{\n  \"type\": \"+\",\n  \"named\": false\n}\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/6-static-node-types.md","header":"Internal Nodes","text_blocks":["NEWPARAGRAPH\nMany syntax nodes can have _children_. The node type object describes the possible children that a node can have using the\nfollowing entries:\nNEWPARAGRAPH\n- `\"fields\"` — An object that describes the possible [fields][node-field-names] that the node can have. The keys of this\nobject are field names, and the values are _child type_ objects, described below.\n- `\"children\"` — Another _child type_ object that describes all the node's possible _named_ children _without_ fields.\nNEWPARAGRAPH\nA _child type_ object describes a set of child nodes using the following entries:\nNEWPARAGRAPH\n- `\"required\"` — A boolean indicating whether there is always _at least one_ node in this set.\n- `\"multiple\"` — A boolean indicating whether there can be _multiple_ nodes in this set.\n- `\"types\"`- An array of objects that represent the possible types of nodes in this set. Each object has two keys: `\"type\"`\nand `\"named\"`, whose meanings are described above.\nNEWPARAGRAPH\nExample with fields:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nExample with children:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n{\n  \"type\": \"method_definition\",\n  \"named\": true,\n  \"fields\": {\n    \"body\": {\n      \"multiple\": false,\n      \"required\": true,\n      \"types\": [{ \"type\": \"statement_block\", \"named\": true }]\n    },\n    \"decorator\": {\n      \"multiple\": true,\n      \"required\": false,\n      \"types\": [{ \"type\": \"decorator\", \"named\": true }]\n    },\n    \"name\": {\n      \"multiple\": false,\n      \"required\": true,\n      \"types\": [\n        { \"type\": \"computed_property_name\", \"named\": true },\n        { \"type\": \"property_identifier\", \"named\": true }\n      ]\n    },\n    \"parameters\": {\n      \"multiple\": false,\n      \"required\": true,\n      \"types\": [{ \"type\": \"formal_parameters\", \"named\": true }]\n    }\n  }\n}\n","\n{\n  \"type\": \"array\",\n  \"named\": true,\n  \"fields\": {},\n  \"children\": {\n    \"multiple\": true,\n    \"required\": false,\n    \"types\": [\n      { \"type\": \"_expression\", \"named\": true },\n      { \"type\": \"spread_element\", \"named\": true }\n    ]\n  }\n}\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/6-static-node-types.md","header":"Supertype Nodes","text_blocks":["NEWPARAGRAPH\nIn Tree-sitter grammars, there are usually certain rules that represent abstract _categories_ of syntax nodes (e.g. \"expression\",\n\"type\", \"declaration\"). In the `grammar.js` file, these are often written as [hidden rules][hidden rules]\nwhose definition is a simple [`choice`][grammar dsl] where each member is just a single symbol.\nNEWPARAGRAPH\nNormally, hidden rules are not mentioned in the node types file, since they don't appear in the syntax tree. But if you add\na hidden rule to the grammar's [`supertypes` list][grammar dsl], then it _will_ show up in the node\ntypes file, with the following special entry:\nNEWPARAGRAPH\n- `\"subtypes\"` — An array of objects that specify the _types_ of nodes that this 'supertype' node can wrap.\nNEWPARAGRAPH\nExample:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nSupertype nodes will also appear elsewhere in the node types file, as children of other node types, in a way that corresponds\nwith how the supertype rule was used in the grammar. This can make the node types much shorter and easier to read, because\na single supertype will take the place of multiple subtypes.\nNEWPARAGRAPH\nExample:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n[grammar dsl]: ../creating-parsers/2-the-grammar-dsl.md\n[hidden rules]: ../creating-parsers/3-writing-the-grammar.md"],"code_blocks":["\n{\n  \"type\": \"_declaration\",\n  \"named\": true,\n  \"subtypes\": [\n    { \"type\": \"class_declaration\", \"named\": true },\n    { \"type\": \"function_declaration\", \"named\": true },\n    { \"type\": \"generator_function_declaration\", \"named\": true },\n    { \"type\": \"lexical_declaration\", \"named\": true },\n    { \"type\": \"variable_declaration\", \"named\": true }\n  ]\n}\n","\n{\n  \"type\": \"export_statement\",\n  \"named\": true,\n  \"fields\": {\n    \"declaration\": {\n      \"multiple\": false,\n      \"required\": false,\n      \"types\": [{ \"type\": \"_declaration\", \"named\": true }]\n    },\n    \"source\": {\n      \"multiple\": false,\n      \"required\": false,\n      \"types\": [{ \"type\": \"string\", \"named\": true }]\n    }\n  }\n}\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/6-static-node-types.md","header":"hiding-rules","text_blocks":["[named-vs-anonymous-nodes]: ./2-basic-parsing.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/6-static-node-types.md","header":"named-vs-anonymous-nodes","text_blocks":["[node-field-names]: ./2-basic-parsing.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/6-static-node-types.md","header":"node-field-names","text_blocks":["[syntax nodes]: ./2-basic-parsing.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/6-static-node-types.md","header":"syntax-nodes","text_blocks":[],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/3-advanced-parsing.md","header":"Advanced Parsing","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/3-advanced-parsing.md","header":"Editing","text_blocks":["NEWPARAGRAPH\nIn applications like text editors, you often need to re-parse a file after its source code has changed. Tree-sitter is designed\nto support this use case efficiently. There are two steps required. First, you must _edit_ the syntax tree, which adjusts\nthe ranges of its nodes so that they stay in sync with the code.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThen, you can call `ts_parser_parse` again, passing in the old tree. This will create a new tree that internally shares structure\nwith the old tree.\nNEWPARAGRAPH\nWhen you edit a syntax tree, the positions of its nodes will change. If you have stored any `TSNode` instances outside of\nthe `TSTree`, you must update their positions separately, using the same `TSInput` value, in order to update their\ncached positions.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis `ts_node_edit` function is _only_ needed in the case where you have retrieved `TSNode` instances _before_ editing the\ntree, and then _after_ editing the tree, you want to continue to use those specific node instances. Often, you'll just want\nto re-fetch nodes from the edited tree, in which case `ts_node_edit` is not needed.\nNEWPARAGRAPH\n"],"code_blocks":["\ntypedef struct {\n  uint32_t start_byte;\n  uint32_t old_end_byte;\n  uint32_t new_end_byte;\n  TSPoint start_point;\n  TSPoint old_end_point;\n  TSPoint new_end_point;\n} TSInputEdit;\nNEWPARAGRAPH\nvoid ts_tree_edit(TSTree *, const TSInputEdit *);\n","\nvoid ts_node_edit(TSNode *, const TSInputEdit *);\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/3-advanced-parsing.md","header":"Multi-language Documents","text_blocks":["NEWPARAGRAPH\nSometimes, different parts of a file may be written in different languages. For example, templating languages like [EJS][ejs]\nand [ERB][erb] allow you to generate HTML by writing a mixture of HTML and another language like JavaScript or Ruby.\nNEWPARAGRAPH\nTree-sitter handles these types of documents by allowing you to create a syntax tree based on the text in certain\n_ranges_ of a file.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nFor example, consider this ERB document:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nConceptually, it can be represented by three syntax trees with overlapping ranges: an ERB syntax tree, a Ruby syntax tree,\nand an HTML syntax tree. You could generate these syntax trees with the following code:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis API allows for great flexibility in how languages can be composed. Tree-sitter is not responsible for mediating the\ninteractions between languages. Instead, you are free to do that using arbitrary application-specific logic.\nNEWPARAGRAPH\n"],"code_blocks":["\ntypedef struct {\n  TSPoint start_point;\n  TSPoint end_point;\n  uint32_t start_byte;\n  uint32_t end_byte;\n} TSRange;\nNEWPARAGRAPH\nvoid ts_parser_set_included_ranges(\n  TSParser *self,\n  const TSRange *ranges,\n  uint32_t range_count\n);\n","\n<ul>\n  <% people.each do |person| %>\n    <li><%= person.name %></li>\n  <% end %>\n</ul>\n","\n#include <string.h>\n#include <tree_sitter/api.h>\nNEWPARAGRAPH\n// These functions are each implemented in their own repo.\nconst TSLanguage *tree_sitter_embedded_template(void);\nconst TSLanguage *tree_sitter_html(void);\nconst TSLanguage *tree_sitter_ruby(void);\nNEWPARAGRAPH\nint main(int argc, const char **argv) {\n  const char *text = argv[1];\n  unsigned len = strlen(text);\nNEWPARAGRAPH\n  // Parse the entire text as ERB.\n  TSParser *parser = ts_parser_new();\n  ts_parser_set_language(parser, tree_sitter_embedded_template());\n  TSTree *erb_tree = ts_parser_parse_string(parser, NULL, text, len);\n  TSNode erb_root_node = ts_tree_root_node(erb_tree);\nNEWPARAGRAPH\n  // In the ERB syntax tree, find the ranges of the `content` nodes,\n  // which represent the underlying HTML, and the `code` nodes, which\n  // represent the interpolated Ruby.\n  TSRange html_ranges[10];\n  TSRange ruby_ranges[10];\n  unsigned html_range_count = 0;\n  unsigned ruby_range_count = 0;\n  unsigned child_count = ts_node_child_count(erb_root_node);\nNEWPARAGRAPH\n  for (unsigned i = 0; i < child_count; i++) {\n    TSNode node = ts_node_child(erb_root_node, i);\n    if (strcmp(ts_node_type(node), \"content\") == 0) {\n      html_ranges[html_range_count++] = (TSRange) {\n        ts_node_start_point(node),\n        ts_node_end_point(node),\n        ts_node_start_byte(node),\n        ts_node_end_byte(node),\n      };\n    } else {\n      TSNode code_node = ts_node_named_child(node, 0);\n      ruby_ranges[ruby_range_count++] = (TSRange) {\n        ts_node_start_point(code_node),\n        ts_node_end_point(code_node),\n        ts_node_start_byte(code_node),\n        ts_node_end_byte(code_node),\n      };\n    }\n  }\nNEWPARAGRAPH\n  // Use the HTML ranges to parse the HTML.\n  ts_parser_set_language(parser, tree_sitter_html());\n  ts_parser_set_included_ranges(parser, html_ranges, html_range_count);\n  TSTree *html_tree = ts_parser_parse_string(parser, NULL, text, len);\n  TSNode html_root_node = ts_tree_root_node(html_tree);\nNEWPARAGRAPH\n  // Use the Ruby ranges to parse the Ruby.\n  ts_parser_set_language(parser, tree_sitter_ruby());\n  ts_parser_set_included_ranges(parser, ruby_ranges, ruby_range_count);\n  TSTree *ruby_tree = ts_parser_parse_string(parser, NULL, text, len);\n  TSNode ruby_root_node = ts_tree_root_node(ruby_tree);\nNEWPARAGRAPH\n  // Print all three trees.\n  char *erb_sexp = ts_node_string(erb_root_node);\n  char *html_sexp = ts_node_string(html_root_node);\n  char *ruby_sexp = ts_node_string(ruby_root_node);\n  printf(\"ERB: %s\\n\", erb_sexp);\n  printf(\"HTML: %s\\n\", html_sexp);\n  printf(\"Ruby: %s\\n\", ruby_sexp);\n  return 0;\n}\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/3-advanced-parsing.md","header":"Concurrency","text_blocks":["NEWPARAGRAPH\nTree-sitter supports multi-threaded use cases by making syntax trees very cheap to copy.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nInternally, copying a syntax tree just entails incrementing an atomic reference count. Conceptually, it provides you a new\ntree which you can freely query, edit, reparse, or delete on a new thread while continuing to use the original tree on a\ndifferent thread.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n[ejs]: https://ejs.co\n[erb]: https://ruby-doc.org/stdlib-2.5.1/libdoc/erb/rdoc/ERB.html"],"code_blocks":["\nTSTree *ts_tree_copy(const TSTree *);\n","\nIndividual `TSTree` instances are _not_ thread safe; you must copy a tree if you want to use it on multiple threads simultaneously.\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/4-walking-trees.md","header":"Walking Trees with Tree Cursors","text_blocks":["NEWPARAGRAPH\nYou can access every node in a syntax tree using the `TSNode` APIs [described earlier][retrieving nodes], but if you need\nto access a large number of nodes, the fastest way to do so is with a _tree cursor_. A cursor is a stateful object that\nallows you to walk a syntax tree with maximum efficiency.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nYou can initialize a cursor from any node:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nYou can move the cursor around the tree:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThese methods return `true` if the cursor successfully moved and `false` if there was no node to move to.\nNEWPARAGRAPH\nYou can always retrieve the cursor's current node, as well as the [field name][node-field-names] that is associated with\nthe current node.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n[retrieving nodes]: ./2-basic-parsing.md"],"code_blocks":["\nThe given input node is considered the root of the cursor, and the cursor cannot walk outside this node.\nGoing to the parent or any sibling of the root node will always return `false`.\nNEWPARAGRAPH\nThis has no unexpected effects if the given input node is the actual `root` node of the tree, but is something to keep in\nmind when using cursors constructed with a node that is not the `root` node.\n","\nTSTreeCursor ts_tree_cursor_new(TSNode);\n","\nbool ts_tree_cursor_goto_first_child(TSTreeCursor *);\nbool ts_tree_cursor_goto_next_sibling(TSTreeCursor *);\nbool ts_tree_cursor_goto_parent(TSTreeCursor *);\n","\nTSNode ts_tree_cursor_current_node(const TSTreeCursor *);\nconst char *ts_tree_cursor_current_field_name(const TSTreeCursor *);\nTSFieldId ts_tree_cursor_current_field_id(const TSTreeCursor *);\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/4-walking-trees.md","header":"retrieving-nodes","text_blocks":["[node-field-names]: ./2-basic-parsing.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/4-walking-trees.md","header":"node-field-names","text_blocks":[],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/index.md","header":"Using Parsers","text_blocks":["NEWPARAGRAPH\nThis guide covers the fundamental concepts of using Tree-sitter, which is applicable across all programming languages.\nAlthough we'll explore some C-specific details that are valuable for direct C API usage or creating new language bindings,\nthe core concepts remain the same.\nNEWPARAGRAPH\nTree-sitter's parsing functionality is implemented through its C API, with all functions documented in the [tree_sitter/api.h][api.h]\nheader file, but if you're working in another language, you can use one of the following bindings found [here](../index.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/index.md","header":"language-bindings),","text_blocks":["each providing idiomatic access to Tree-sitter's functionality. Of these bindings, the official ones have their own API docs\nhosted online at the following pages:\nNEWPARAGRAPH\n- [Go][go]\n- [Java]\n- [JavaScript (Node.js)][javascript]\n- [Kotlin][kotlin]\n- [Python][python]\n- [Rust][rust]\n- [Zig][zig]\nNEWPARAGRAPH\n[api.h]: https://github.com/tree-sitter/tree-sitter/blob/master/lib/include/tree_sitter/api.h\n[go]: https://pkg.go.dev/github.com/tree-sitter/go-tree-sitter\n[java]: https://tree-sitter.github.io/java-tree-sitter\n[javascript]: https://tree-sitter.github.io/node-tree-sitter\n[kotlin]: https://tree-sitter.github.io/kotlin-tree-sitter\n[python]: https://tree-sitter.github.io/py-tree-sitter\n[rust]: https://docs.rs/tree-sitter\n[zig]: https://tree-sitter.github.io/zig-tree-sitter"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/1-syntax.md","header":"Query Syntax","text_blocks":["NEWPARAGRAPH\nA _query_ consists of one or more _patterns_, where each pattern is an [S-expression][s-exp] that matches a certain set of\nnodes in a syntax tree. The expression to match a given node consists of a pair of parentheses containing two things: the\nnode's type, and optionally, a series of other S-expressions that match the node's children. For example, this pattern would\nmatch any `binary_expression` node whose children are both `number_literal` nodes:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nChildren can also be omitted. For example, this would match any `binary_expression` where at least _one_ of child is a\n`string_literal` node:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n(binary_expression (number_literal) (number_literal))\n","\n(binary_expression (string_literal))\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/1-syntax.md","header":"Fields","text_blocks":["NEWPARAGRAPH\nIn general, it's a good idea to make patterns more specific by specifying [field names][node-field-names] associated with\nchild nodes. You do this by prefixing a child pattern with a field name followed by a colon. For example, this pattern would\nmatch an `assignment_expression` node where the `left` child is a `member_expression` whose `object` is a `call_expression`.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n(assignment_expression\n  left: (member_expression\n    object: (call_expression)))\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/1-syntax.md","header":"Negated Fields","text_blocks":["NEWPARAGRAPH\nYou can also constrain a pattern so that it only matches nodes that _lack_ a certain field. To do this, add a field name\nprefixed by a `!` within the parent pattern. For example, this pattern would match a class declaration with no type parameters:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n(class_declaration\n  name: (identifier) @class_name\n  !type_parameters)\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/1-syntax.md","header":"Anonymous Nodes","text_blocks":["NEWPARAGRAPH\nThe parenthesized syntax for writing nodes only applies to [named nodes][named-vs-anonymous-nodes]. To match specific anonymous\nnodes, you write their name between double quotes. For example, this pattern would match any `binary_expression` where the\noperator is `!=` and the right side is `null`:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n(binary_expression\n  operator: \"!=\"\n  right: (null))\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/1-syntax.md","header":"Special Nodes","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/1-syntax.md","header":"The Wildcard Node","text_blocks":["NEWPARAGRAPH\nA wildcard node is represented with an underscore (`_`), it matches any node.\nThis is similar to `.` in regular expressions.\nThere are two types, `(_)` will match any named node,\nand `_` will match any named or anonymous node.\nNEWPARAGRAPH\nFor example, this pattern would match any node inside a call:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n(call (_) @call.inner)\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/1-syntax.md","header":"The `ERROR` Node","text_blocks":["NEWPARAGRAPH\nWhen the parser encounters text it does not recognize, it represents this node\nas `(ERROR)` in the syntax tree. These error nodes can be queried just like\nnormal nodes:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n(ERROR) @error-node\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/1-syntax.md","header":"The `MISSING` Node","text_blocks":["NEWPARAGRAPH\nIf the parser is able to recover from erroneous text by inserting a missing token and then reducing, it will insert that\nmissing node in the final tree so long as that tree has the lowest error cost. These missing nodes appear as seemingly normal\nnodes in the tree, but they are zero tokens wide, and are internally represented as a property of the actual terminal node\nthat was inserted, instead of being its own kind of node, like the `ERROR` node. These special missing nodes can be queried\nusing `(MISSING)`:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis is useful when attempting to detect all syntax errors in a given parse tree, since these missing node are not captured\nby `(ERROR)` queries. Specific missing node types can also be queried:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n[node-field-names]: ../2-basic-parsing.md"],"code_blocks":["\n(MISSING) @missing-node\n","\n(MISSING identifier) @missing-identifier\n(MISSING \";\") @missing-semicolon\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/1-syntax.md","header":"node-field-names","text_blocks":["[named-vs-anonymous-nodes]: ../2-basic-parsing.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/1-syntax.md","header":"named-vs-anonymous-nodes","text_blocks":["[s-exp]: https://en.wikipedia.org/wiki/S-expression"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/2-operators.md","header":"Operators","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/2-operators.md","header":"Capturing Nodes","text_blocks":["NEWPARAGRAPH\nWhen matching patterns, you may want to process specific nodes within the pattern. Captures allow you to associate names\nwith specific nodes in a pattern, so that you can later refer to those nodes by those names. Capture names are written _after_\nthe nodes that they refer to, and start with an `@` character.\nNEWPARAGRAPH\nFor example, this pattern would match any assignment of a `function` to an `identifier`, and it would associate the name\n`the-function-name` with the identifier:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nAnd this pattern would match all method definitions, associating the name `the-method-name` with the method name, `the-class-name`\nwith the containing class name:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n(assignment_expression\n  left: (identifier) @the-function-name\n  right: (function))\n","\n(class_declaration\n  name: (identifier) @the-class-name\n  body: (class_body\n    (method_definition\n      name: (property_identifier) @the-method-name)))\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/2-operators.md","header":"Quantification Operators","text_blocks":["NEWPARAGRAPH\nYou can match a repeating sequence of sibling nodes using the postfix `+` and `*` _repetition_ operators, which work analogously\nto the `+` and `*` operators [in regular expressions][regex]. The `+` operator matches _one or more_ repetitions of a pattern,\nand the `*` operator matches _zero or more_.\nNEWPARAGRAPH\nFor example, this pattern would match a sequence of one or more comments:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis pattern would match a class declaration, capturing all of the decorators if any were present:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nYou can also mark a node as optional using the `?` operator. For example, this pattern would match all function calls, capturing\na string argument if one was present:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n(comment)+\n","\n(class_declaration\n  (decorator)* @the-decorator\n  name: (identifier) @the-name)\n","\n(call_expression\n  function: (identifier) @the-function\n  arguments: (arguments (string)? @the-string-arg))\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/2-operators.md","header":"Grouping Sibling Nodes","text_blocks":["NEWPARAGRAPH\nYou can also use parentheses for grouping a sequence of _sibling_ nodes. For example, this pattern would match a comment\nfollowed by a function declaration:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nAny of the quantification operators mentioned above (`+`, `*`, and `?`) can also be applied to groups. For example, this\npattern would match a comma-separated series of numbers:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n(\n  (comment)\n  (function_declaration)\n)\n","\n(\n  (number)\n  (\",\" (number))*\n)\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/2-operators.md","header":"Alternations","text_blocks":["NEWPARAGRAPH\nAn alternation is written as a pair of square brackets (`[]`) containing a list of alternative patterns.\nThis is similar to _character classes_ from regular expressions (`[abc]` matches either a, b, or c).\nNEWPARAGRAPH\nFor example, this pattern would match a call to either a variable or an object property.\nIn the case of a variable, capture it as `@function`, and in the case of a property, capture it as `@method`:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis pattern would match a set of possible keyword tokens, capturing them as `@keyword`:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n(call_expression\n  function: [\n    (identifier) @function\n    (member_expression\n      property: (property_identifier) @method)\n  ])\n","\n[\n  \"break\"\n  \"delete\"\n  \"else\"\n  \"for\"\n  \"function\"\n  \"if\"\n  \"return\"\n  \"try\"\n  \"while\"\n] @keyword\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/2-operators.md","header":"Anchors","text_blocks":["NEWPARAGRAPH\nThe anchor operator, `.`, is used to constrain the ways in which child patterns are matched. It has different behaviors\ndepending on where it's placed inside a query.\nNEWPARAGRAPH\nWhen `.` is placed before the _first_ child within a parent pattern, the child will only match when it is the first named\nnode in the parent. For example, the below pattern matches a given `array` node at most once, assigning the `@the-element`\ncapture to the first `identifier` node in the parent `array`:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nWithout this anchor, the pattern would match once for every identifier in the array, with `@the-element` bound\nto each matched identifier.\nNEWPARAGRAPH\nSimilarly, an anchor placed after a pattern's _last_ child will cause that child pattern to only match nodes that are the\nlast named child of their parent. The below pattern matches only nodes that are the last named child within a `block`.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nFinally, an anchor _between_ two child patterns will cause the patterns to only match nodes that are immediate siblings.\nThe pattern below, given a long dotted name like `a.b.c.d`, will only match pairs of consecutive identifiers:\n`a, b`, `b, c`, and `c, d`.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nWithout the anchor, non-consecutive pairs like `a, c` and `b, d` would also be matched.\nNEWPARAGRAPH\nThe restrictions placed on a pattern by an anchor operator ignore anonymous nodes.\nNEWPARAGRAPH\n[regex]: https://en.wikipedia.org/wiki/Regular_expression"],"code_blocks":["\n(array . (identifier) @the-element)\n","\n(block (_) @last-expression .)\n","\n(dotted_name\n  (identifier) @prev-id\n  .\n  (identifier) @next-id)\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/2-operators.md","header":"Basic_concepts","text_blocks":[],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/index.md","header":"Pattern Matching with Queries","text_blocks":["NEWPARAGRAPH\nCode analysis often requires finding specific patterns in source code. Tree-sitter provides a simple pattern-matching\nlanguage for this purpose, similar to what's used in its [unit test system][unit testing].\nThis allows you to express and search for code structures without writing complex parsing logic.\nNEWPARAGRAPH\n[unit testing]: ../../creating-parsers/5-writing-tests.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/4-api.md","header":"The Query API","text_blocks":["NEWPARAGRAPH\nCreate a query by specifying a string containing one or more patterns:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nIf there is an error in the query, then the `error_offset` argument will be set to the byte offset of the error, and the\n`error_type` argument will be set to a value that indicates the type of error:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThe `TSQuery` value is immutable and can be safely shared between threads. To execute the query, create a `TSQueryCursor`,\nwhich carries the state needed for processing the queries. The query cursor should not be shared between threads, but can\nbe reused for many query executions.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nYou can then execute the query on a given syntax node:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nYou can then iterate over the matches:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis function will return `false` when there are no more matches. Otherwise, it will populate the `match` with data about\nwhich pattern matched and which nodes were captured."],"code_blocks":["\nTSQuery *ts_query_new(\n  const TSLanguage *language,\n  const char *source,\n  uint32_t source_len,\n  uint32_t *error_offset,\n  TSQueryError *error_type\n);\n","\ntypedef enum {\n  TSQueryErrorNone = 0,\n  TSQueryErrorSyntax,\n  TSQueryErrorNodeType,\n  TSQueryErrorField,\n  TSQueryErrorCapture,\n} TSQueryError;\n","\nTSQueryCursor *ts_query_cursor_new(void);\n","\nvoid ts_query_cursor_exec(TSQueryCursor *, const TSQuery *, TSNode);\n","\ntypedef struct {\n  TSNode node;\n  uint32_t index;\n} TSQueryCapture;\nNEWPARAGRAPH\ntypedef struct {\n  uint32_t id;\n  uint16_t pattern_index;\n  uint16_t capture_count;\n  const TSQueryCapture *captures;\n} TSQueryMatch;\nNEWPARAGRAPH\nbool ts_query_cursor_next_match(TSQueryCursor *, TSQueryMatch *match);\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"Predicates","text_blocks":["NEWPARAGRAPH\nYou can also specify arbitrary metadata and conditions associated with a pattern\nby adding _predicate_ S-expressions anywhere within your pattern. Predicate S-expressions\nstart with a _predicate name_ beginning with a `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"` character, and ending with a `?` character. After that, they can","text_blocks":["contain an arbitrary number of `@`-prefixed capture names or strings.\nNEWPARAGRAPH\nTree-sitter's CLI supports the following predicates by default:\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"The `eq?` predicate","text_blocks":["NEWPARAGRAPH\nThis family of predicates allows you to match against a single capture or string\nvalue.\nNEWPARAGRAPH\nThe first argument to this predicate must be a capture, but the second can be either a capture to\ncompare the two captures' text, or a string to compare first capture's text\nagainst.\nNEWPARAGRAPH\nThe base predicate is `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"eq?`, but its complement, `#not-eq?`, can be used to _not_","text_blocks":["match a value. Additionally, you can prefix either of these with `any-` to match\nif _any_ of the nodes match the predicate. This is only useful when dealing with\nquantified captures, as by default a quantified capture will only match if _all_ the captured nodes match the predicate.\nNEWPARAGRAPH\nThus, there are four predicates in total:\nNEWPARAGRAPH\n- `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"eq?`","text_blocks":["- `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"not-eq?`","text_blocks":["- `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"any-eq?`","text_blocks":["- `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"any-not-eq?`","text_blocks":["NEWPARAGRAPH\nConsider the following example targeting C:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis pattern would match any identifier that is `self`.\nNEWPARAGRAPH\nNow consider the following example:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis pattern would match key-value pairs where the `value` is an identifier\nwith the same text as the key (meaning they are the same):\nNEWPARAGRAPH\nAs mentioned earlier, the `any-` prefix is meant for use with quantified captures. Here's\nan example finding an empty comment within a group of comments:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n((identifier) @variable.builtin\n  (#eq? @variable.builtin \"self\"))\n","\n(\n  (pair\n    key: (property_identifier) @key-name\n    value: (identifier) @value-name)\n  (#eq? @key-name @value-name)\n)\n","\n((comment)+ @comment.empty\n  (#any-eq? @comment.empty \"//\"))\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"The `match?` predicate","text_blocks":["NEWPARAGRAPH\nThese predicates are similar to the `eq?` predicates, but they use regular expressions\nto match against the capture's text instead of string comparisons.\nNEWPARAGRAPH\nThe first argument must be a capture, and the second must be a string containing\na regular expression.\nNEWPARAGRAPH\nLike the `eq?` predicate family, we can tack on `not-` to the beginning of the predicate\nto negate the match, and `any-` to match if _any_ of the nodes in a quantified capture match the predicate.\nNEWPARAGRAPH\nThis pattern matches identifiers written in `SCREAMING_SNAKE_CASE`.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis query identifies documentation comments in C that begin with three forward slashes (`///`).\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis query finds C code embedded in Go comments that appear just before a \"C\" import statement.\nThese are known as [`Cgo`][cgo] comments and are used to inject C code into Go programs.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n((identifier) @constant\n  (#match? @constant \"^[A-Z][A-Z_]+\"))\n","\n((comment)+ @comment.documentation\n  (#match? @comment.documentation \"^///\\\\s+.*\"))\n","\n((comment)+ @injection.content\n  .\n  (import_declaration\n    (import_spec path: (interpreted_string_literal) @_import_c))\n  (#eq? @_import_c \"\\\"C\\\"\")\n  (#match? @injection.content \"^//\"))\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"The `any-of?` predicate","text_blocks":["NEWPARAGRAPH\nThe `any-of?` predicate allows you to match a capture against multiple strings,\nand will match if the capture's text is equal to any of the strings.\nNEWPARAGRAPH\nThe query below will match any of the builtin variables in JavaScript.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n((identifier) @variable.builtin\n  (#any-of? @variable.builtin\n        \"arguments\"\n        \"module\"\n        \"console\"\n        \"window\"\n        \"document\"))\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"The `is?` predicate","text_blocks":["NEWPARAGRAPH\nThe `is?` predicate allows you to assert that a capture has a given property. This isn't widely used, but the CLI uses it\nto determine whether a given node is a local variable or not, for example:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis pattern would match any builtin variable that is not a local variable, because the `"],"code_blocks":["\n((identifier) @variable.builtin\n  (#match? @variable.builtin \"^(arguments|module|console|window|document)$\")\n  (#is-not? local))\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"is-not? local` predicate is used.","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"Directives","text_blocks":["NEWPARAGRAPH\nSimilar to predicates, directives are a way to associate arbitrary metadata with a pattern. The only difference between predicates\nand directives is that directives end in a `!` character instead of `?` character.\nNEWPARAGRAPH\nTree-sitter's CLI supports the following directives by default:\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"The `set!` directive","text_blocks":["NEWPARAGRAPH\nThis directive allows you to associate key-value pairs with a pattern. The key and value can be any arbitrary text that you\nsee fit.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis pattern would match any comment that contains a Doxygen-style comment, and then sets the `injection.language` key to\n`\"doxygen\"`. Programmatically, when iterating the captures of this pattern, you can access this property to then parse the\ncomment with the Doxygen parser.\nNEWPARAGRAPH\n"],"code_blocks":["\n((comment) @injection.content\n  (#lua-match? @injection.content \"/[*\\/][!*\\/]<?[^a-zA-Z]\")\n  (#set! injection.language \"doxygen\"))\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"The `#select-adjacent!` directive","text_blocks":["NEWPARAGRAPH\nThe `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"select-adjacent!` directive allows you to filter the text associated with a capture so that only nodes adjacent to","text_blocks":["another capture are preserved. It takes two arguments, both of which are capture names.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"The `#strip!` directive","text_blocks":["NEWPARAGRAPH\nThe `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"strip!` directive allows you to remove text from a capture. It takes two arguments: the first is the capture to strip","text_blocks":["text from, and the second is a regular expression to match against the text. Any text matched by the regular expression will\nbe removed from the text associated with the capture.\nNEWPARAGRAPH\nFor an example on the `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"select-adjacent!` and `#strip!` directives,","text_blocks":["view the [code navigation](../../4-code-navigation.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"examples) documentation.","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"Recap","text_blocks":["NEWPARAGRAPH\nTo recap about the predicates and directives Tree-Sitter's bindings support:\nNEWPARAGRAPH\n- `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"eq?` checks for a direct match against a capture or string","text_blocks":["NEWPARAGRAPH\n- `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"match?` checks for a match against a regular expression","text_blocks":["NEWPARAGRAPH\n- `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"any-of?` checks for a match against a list of strings","text_blocks":["NEWPARAGRAPH\n- `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"is?` checks for a property on a capture","text_blocks":["NEWPARAGRAPH\n- Adding `not-` to the beginning of these predicates will negate the match\nNEWPARAGRAPH\n- By default, a quantified capture will only match if _all_ the nodes match the predicate\nNEWPARAGRAPH\n- Adding `any-` before the `eq` or `match` predicates will instead match if any of the nodes match the predicate\nNEWPARAGRAPH\n- `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"set!` associates key-value pairs with a pattern","text_blocks":["NEWPARAGRAPH\n- `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"select-adjacent!` filters the text associated with a capture so that only nodes adjacent to another capture are preserved","text_blocks":["NEWPARAGRAPH\n- `"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/queries/3-predicates-and-directives.md","header":"strip!` removes text from a capture","text_blocks":["NEWPARAGRAPH\n","NEWPARAGRAPH\n[cgo]: https://pkg.go.dev/cmd/cgo\n[rust crate]: https://github.com/tree-sitter/tree-sitter/tree/master/lib/binding_rust\n[wasm binding]: https://github.com/tree-sitter/tree-sitter/tree/master/lib/binding_web"],"code_blocks":["\nPredicates and directives are not handled directly by the Tree-sitter C library.\nThey are just exposed in a structured form so that higher-level code can perform\nthe filtering. However, higher-level bindings to Tree-sitter like\n[the Rust Crate][rust crate]\nor the [WebAssembly binding][wasm binding]\ndo implement a few common predicates like those explained above. In the future, more \"standard\" predicates and directives\nmay be added.\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/2-basic-parsing.md","header":"Basic Parsing","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/2-basic-parsing.md","header":"Providing the Code","text_blocks":["NEWPARAGRAPH\nIn the example on the previous page, we parsed source code stored in a simple string using the `ts_parser_parse_string` function:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nYou may want to parse source code that's stored in a custom data structure, like a [piece table][piece table] or a [rope][rope].\nIn this case, you can use the more general `ts_parser_parse` function:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThe `TSInput` structure lets you provide your own function for reading a chunk of text at a given byte offset and row/column\nposition. The function can return text encoded in either UTF-8 or UTF-16. This interface allows you to efficiently parse\ntext that is stored in your own data structure.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nIf you want to decode text that is not encoded in UTF-8 or UTF-16, you can set the `decode` field of the input to your function\nthat will decode text. The signature of the `DecodeFunction` is as follows:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n","NEWPARAGRAPH\nThe `string` argument is a pointer to the text to decode, which comes from the `read` function, and the `length` argument\nis the length of the `string`. The `code_point` argument is a pointer to an integer that represents the decoded code point,\nand should be written to in your `decode` callback. The function should return the number of bytes decoded.\nNEWPARAGRAPH\n"],"code_blocks":["\nTSTree *ts_parser_parse_string(\n  TSParser *self,\n  const TSTree *old_tree,\n  const char *string,\n  uint32_t length\n);\n","\nTSTree *ts_parser_parse(\n  TSParser *self,\n  const TSTree *old_tree,\n  TSInput input\n);\n","\ntypedef struct {\n  void *payload;\n  const char *(*read)(\n    void *payload,\n    uint32_t byte_offset,\n    TSPoint position,\n    uint32_t *bytes_read\n  );\n  TSInputEncoding encoding;\n  DecodeFunction decode;\n} TSInput;\n","\ntypedef uint32_t (*DecodeFunction)(\n  const uint8_t *string,\n  uint32_t length,\n  int32_t *code_point\n);\n","\nThe `TSInputEncoding` must be set to `TSInputEncodingCustom` for the `decode` function to be called.\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/2-basic-parsing.md","header":"Syntax Nodes","text_blocks":["NEWPARAGRAPH\nTree-sitter provides a [DOM][dom]-style interface for inspecting syntax trees.\nA syntax node's _type_ is a string that indicates which grammar rule the node represents.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nSyntax nodes store their position in the source code both in raw bytes and row/column\ncoordinates. In a point, rows and columns are zero-based. The `row` field represents\nthe number of newlines before a given position, while `column` represents the number\nof bytes between the position and beginning of the line.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\nconst char *ts_node_type(TSNode);\n","\nuint32_t ts_node_start_byte(TSNode);\nuint32_t ts_node_end_byte(TSNode);\ntypedef struct {\n  uint32_t row;\n  uint32_t column;\n} TSPoint;\nTSPoint ts_node_start_point(TSNode);\nTSPoint ts_node_end_point(TSNode);\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/2-basic-parsing.md","header":"Retrieving Nodes","text_blocks":["NEWPARAGRAPH\nEvery tree has a _root node_:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nOnce you have a node, you can access the node's children:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nYou can also access its siblings and parent:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThese methods may all return a _null node_ to indicate, for example, that a node does not _have_ a next sibling.\nYou can check if a node is null:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\nTSNode ts_tree_root_node(const TSTree *);\n","\nuint32_t ts_node_child_count(TSNode);\nTSNode ts_node_child(TSNode, uint32_t);\n","\nTSNode ts_node_next_sibling(TSNode);\nTSNode ts_node_prev_sibling(TSNode);\nTSNode ts_node_parent(TSNode);\n","\nbool ts_node_is_null(TSNode);\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/2-basic-parsing.md","header":"Named vs Anonymous Nodes","text_blocks":["NEWPARAGRAPH\nTree-sitter produces [_concrete_ syntax trees][cst] — trees that contain nodes for\nevery individual token in the source code, including things like commas and parentheses. This is important for use-cases\nthat deal with individual tokens, like [syntax highlighting][syntax highlighting]. But some\ntypes of code analysis are easier to perform using an [_abstract_ syntax tree][ast] — a tree in which the less important\ndetails have been removed. Tree-sitter's trees support these use cases by making a distinction between\n_named_ and _anonymous_ nodes.\nNEWPARAGRAPH\nConsider a grammar rule like this:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nA syntax node representing an `if_statement` in this language would have 5 children: the condition expression, the body statement,\nas well as the `if`, `(`, and `)` tokens. The expression and the statement would be marked as _named_ nodes, because they\nhave been given explicit names in the grammar. But the `if`, `(`, and `)` nodes would _not_ be named nodes, because they\nare represented in the grammar as simple strings.\nNEWPARAGRAPH\nYou can check whether any given node is named:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nWhen traversing the tree, you can also choose to skip over anonymous nodes by using the `_named_` variants of all of the\nmethods described above:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nIf you use this group of methods, the syntax tree functions much like an abstract syntax tree.\nNEWPARAGRAPH\n"],"code_blocks":["\nif_statement: $ => seq(\"if\", \"(\", $._expression, \")\", $._statement);\n","\nbool ts_node_is_named(TSNode);\n","\nTSNode ts_node_named_child(TSNode, uint32_t);\nuint32_t ts_node_named_child_count(TSNode);\nTSNode ts_node_next_named_sibling(TSNode);\nTSNode ts_node_prev_named_sibling(TSNode);\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/2-basic-parsing.md","header":"Node Field Names","text_blocks":["NEWPARAGRAPH\nTo make syntax nodes easier to analyze, many grammars assign unique _field names_ to particular child nodes.\nIn the [creating parsers][using fields] section, it's explained how to do this in your own grammars. If a syntax node has\nfields, you can access its children using their field name:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nFields also have numeric ids that you can use, if you want to avoid repeated string comparisons. You can convert between\nstrings and ids using the `TSLanguage`:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThe field ids can be used in place of the name:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n[ast]: https://en.wikipedia.org/wiki/Abstract_syntax_tree\n[cst]: https://en.wikipedia.org/wiki/Parse_tree\n[dom]: https://en.wikipedia.org/wiki/Document_Object_Model\n[piece table]: <https://en.wikipedia.org/wiki/Piece_table>\n[rope]: <https://en.wikipedia.org/wiki/Rope_(data_structure)>\n[syntax highlighting]: https://en.wikipedia.org/wiki/Syntax_highlighting\n[using fields]: ../creating-parsers/3-writing-the-grammar.md"],"code_blocks":["\nTSNode ts_node_child_by_field_name(\n  TSNode self,\n  const char *field_name,\n  uint32_t field_name_length\n);\n","\nuint32_t ts_language_field_count(const TSLanguage *);\nconst char *ts_language_field_name_for_id(const TSLanguage *, TSFieldId);\nTSFieldId ts_language_field_id_for_name(const TSLanguage *, const char *, uint32_t);\n","\nTSNode ts_node_child_by_field_id(TSNode, TSFieldId);\n"]},{"file_path":"tree-sitter/docs/src/using-parsers/2-basic-parsing.md","header":"using-fields","text_blocks":[],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/1-getting-started.md","header":"Getting Started","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/1-getting-started.md","header":"Building the Library","text_blocks":["NEWPARAGRAPH\nTo build the library on a POSIX system, just run `make` in the Tree-sitter directory. This will create a static library\ncalled `libtree-sitter.a` as well as dynamic libraries.\nNEWPARAGRAPH\nAlternatively, you can incorporate the library in a larger project's build system by adding one source file to the build.\nThis source file needs two directories to be in the include path when compiled:\nNEWPARAGRAPH\n**source file:**\nNEWPARAGRAPH\n- `tree-sitter/lib/src/lib.c`\nNEWPARAGRAPH\n**include directories:**\nNEWPARAGRAPH\n- `tree-sitter/lib/src`\n- `tree-sitter/lib/include`\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/1-getting-started.md","header":"The Basic Objects","text_blocks":["NEWPARAGRAPH\nThere are four main types of objects involved when using Tree-sitter: languages, parsers, syntax trees, and syntax nodes.\nIn C, these are called `TSLanguage`, `TSParser`, `TSTree`, and `TSNode`.\nNEWPARAGRAPH\n- A `TSLanguage` is an opaque object that defines how to parse a particular programming language. The code for each `TSLanguage`\nis generated by Tree-sitter. Many languages are already available in separate git repositories within the\n[Tree-sitter GitHub organization][ts org] and the [Tree-sitter grammars GitHub organization][tsg org].\nSee [the next section][creating parsers] for how to create new languages.\nNEWPARAGRAPH\n- A `TSParser` is a stateful object that can be assigned a `TSLanguage` and used to produce a `TSTree` based on some\nsource code.\nNEWPARAGRAPH\n- A `TSTree` represents the syntax tree of an entire source code file. It contains `TSNode` instances that indicate the\nstructure of the source code. It can also be edited and used to produce a new `TSTree` in the event that the\nsource code changes.\nNEWPARAGRAPH\n- A `TSNode` represents a single node in the syntax tree. It tracks its start and end positions in the source code, as\nwell as its relation to other nodes like its parent, siblings and children.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/using-parsers/1-getting-started.md","header":"An Example Program","text_blocks":["NEWPARAGRAPH\nHere's an example of a simple C program that uses the Tree-sitter [JSON parser][json].\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis program requires three components to build:\nNEWPARAGRAPH\n1. The Tree-sitter C API from `tree-sitter/api.h` (requiring `tree-sitter/lib/include` in our include path)\n2. The Tree-sitter library (`libtree-sitter.a`)\n3. The JSON grammar's source code, which we compile directly into the binary\nNEWPARAGRAPH\n","NEWPARAGRAPH\nWhen using dynamic linking, you'll need to ensure the shared library is discoverable through `LD_LIBRARY_PATH` or your system's\nequivalent environment variable. Here's how to compile with dynamic linking:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n[creating parsers]: ../creating-parsers/index.md\n[json]: https://github.com/tree-sitter/tree-sitter-json\n[ts org]: https://github.com/tree-sitter\n[tsg org]: https://github.com/tree-sitter-grammars"],"code_blocks":["\n// Filename - test-json-parser.c\nNEWPARAGRAPH\n#include <assert.h>\n#include <string.h>\n#include <stdio.h>\n#include <tree_sitter/api.h>\nNEWPARAGRAPH\n// Declare the `tree_sitter_json` function, which is\n// implemented by the `tree-sitter-json` library.\nconst TSLanguage *tree_sitter_json(void);\nNEWPARAGRAPH\nint main() {\n  // Create a parser.\n  TSParser *parser = ts_parser_new();\nNEWPARAGRAPH\n  // Set the parser's language (JSON in this case).\n  ts_parser_set_language(parser, tree_sitter_json());\nNEWPARAGRAPH\n  // Build a syntax tree based on source code stored in a string.\n  const char *source_code = \"[1, null]\";\n  TSTree *tree = ts_parser_parse_string(\n    parser,\n    NULL,\n    source_code,\n    strlen(source_code)\n  );\nNEWPARAGRAPH\n  // Get the root node of the syntax tree.\n  TSNode root_node = ts_tree_root_node(tree);\nNEWPARAGRAPH\n  // Get some child nodes.\n  TSNode array_node = ts_node_named_child(root_node, 0);\n  TSNode number_node = ts_node_named_child(array_node, 0);\nNEWPARAGRAPH\n  // Check that the nodes have the expected types.\n  assert(strcmp(ts_node_type(root_node), \"document\") == 0);\n  assert(strcmp(ts_node_type(array_node), \"array\") == 0);\n  assert(strcmp(ts_node_type(number_node), \"number\") == 0);\nNEWPARAGRAPH\n  // Check that the nodes have the expected child counts.\n  assert(ts_node_child_count(root_node) == 1);\n  assert(ts_node_child_count(array_node) == 5);\n  assert(ts_node_named_child_count(array_node) == 2);\n  assert(ts_node_child_count(number_node) == 0);\nNEWPARAGRAPH\n  // Print the syntax tree as an S-expression.\n  char *string = ts_node_string(root_node);\n  printf(\"Syntax tree: %s\\n\", string);\nNEWPARAGRAPH\n  // Free all of the heap-allocated memory.\n  free(string);\n  ts_tree_delete(tree);\n  ts_parser_delete(parser);\n  return 0;\n}\n","\nclang                                   \\\n  -I tree-sitter/lib/include            \\\n  test-json-parser.c                    \\\n  tree-sitter-json/src/parser.c         \\\n  tree-sitter/libtree-sitter.a          \\\n  -o test-json-parser\n./test-json-parser\n","\nclang                                   \\\n  -I tree-sitter/lib/include            \\\n  test-json-parser.c                    \\\n  tree-sitter-json/src/parser.c         \\\n  -ltree-sitter                         \\\n  -o test-json-parser\n./test-json-parser\n"]},{"file_path":"tree-sitter/docs/src/index.md","header":"Introduction","text_blocks":["NEWPARAGRAPH\nTree-sitter is a parser generator tool and an incremental parsing library. It can build a concrete syntax tree for a source\nfile and efficiently update the syntax tree as the source file is edited. Tree-sitter aims to be:\nNEWPARAGRAPH\n- **General** enough to parse any programming language\n- **Fast** enough to parse on every keystroke in a text editor\n- **Robust** enough to provide useful results even in the presence of syntax errors\n- **Dependency-free** so that the runtime library (which is written in pure [C11](https://github.com/tree-sitter/tree-sitter/tree/master/lib)) can be embedded in any application\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/index.md","header":"Language Bindings","text_blocks":["NEWPARAGRAPH\nThere are bindings that allow Tree-sitter to be used from the following languages:\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/index.md","header":"Official","text_blocks":["NEWPARAGRAPH\n- [C"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/index.md","header":"](https://github.com/tree-sitter/csharp-tree-sitter)","text_blocks":["- [Go](https://github.com/tree-sitter/go-tree-sitter)\n- [Haskell](https://github.com/tree-sitter/haskell-tree-sitter)\n- [Java (JDK 22)](https://github.com/tree-sitter/java-tree-sitter)\n- [JavaScript (Node.js)](https://github.com/tree-sitter/node-tree-sitter)\n- [JavaScript (Wasm)](https://github.com/tree-sitter/tree-sitter/tree/master/lib/binding_web)\n- [Kotlin](https://github.com/tree-sitter/kotlin-tree-sitter)\n- [Python](https://github.com/tree-sitter/py-tree-sitter)\n- [Rust](https://github.com/tree-sitter/tree-sitter/tree/master/lib/binding_rust)\n- [Zig](https://github.com/tree-sitter/zig-tree-sitter)\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/index.md","header":"Third-party","text_blocks":["NEWPARAGRAPH\n- [Delphi](https://github.com/modersohn/delphi-tree-sitter)\n- [ELisp](https://www.gnu.org/software/emacs/manual/html_node/elisp/Parsing-Program-Source.html)\n- [Guile](https://github.com/Z572/guile-ts)\n- [Java (JDK 8+)](https://github.com/bonede/tree-sitter-ng)\n- [Java (JDK 11+)](https://github.com/seart-group/java-tree-sitter)\n- [Julia](https://github.com/MichaelHatherly/TreeSitter.jl)\n- [Lua](https://github.com/euclidianAce/ltreesitter)\n- [Lua](https://github.com/xcb-xwii/lua-tree-sitter)\n- [OCaml](https://github.com/returntocorp/ocaml-tree-sitter-core)\n- [Odin](https://github.com/laytan/odin-tree-sitter)\n- [Perl](https://metacpan.org/pod/Text::Treesitter)\n- [R](https://github.com/DavisVaughan/r-tree-sitter)\n- [Ruby](https://github.com/Faveod/ruby-tree-sitter)\n- [Ruby](https://github.com/calicoday/ruby-tree-sitter-ffi)\n- [Swift](https://github.com/ChimeHQ/SwiftTreeSitter)\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/index.md","header":"Parsers","text_blocks":["NEWPARAGRAPH\nThe following parsers can be found in the upstream organization:\nNEWPARAGRAPH\n- [Agda](https://github.com/tree-sitter/tree-sitter-agda)\n- [Bash](https://github.com/tree-sitter/tree-sitter-bash)\n- [C](https://github.com/tree-sitter/tree-sitter-c)\n- [C++](https://github.com/tree-sitter/tree-sitter-cpp)\n- [C"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/index.md","header":"](https://github.com/tree-sitter/tree-sitter-c-sharp)","text_blocks":["- [CSS](https://github.com/tree-sitter/tree-sitter-css)\n- [ERB / EJS](https://github.com/tree-sitter/tree-sitter-embedded-template)\n- [Go](https://github.com/tree-sitter/tree-sitter-go)\n- [Haskell](https://github.com/tree-sitter/tree-sitter-haskell)\n- [HTML](https://github.com/tree-sitter/tree-sitter-html)\n- [Java](https://github.com/tree-sitter/tree-sitter-java)\n- [JavaScript](https://github.com/tree-sitter/tree-sitter-javascript)\n- [JSDoc](https://github.com/tree-sitter/tree-sitter-jsdoc)\n- [JSON](https://github.com/tree-sitter/tree-sitter-json)\n- [Julia](https://github.com/tree-sitter/tree-sitter-julia)\n- [OCaml](https://github.com/tree-sitter/tree-sitter-ocaml)\n- [PHP](https://github.com/tree-sitter/tree-sitter-php)\n- [Python](https://github.com/tree-sitter/tree-sitter-python)\n- [Regex](https://github.com/tree-sitter/tree-sitter-regex)\n- [Ruby](https://github.com/tree-sitter/tree-sitter-ruby)\n- [Rust](https://github.com/tree-sitter/tree-sitter-rust)\n- [Scala](https://github.com/tree-sitter/tree-sitter-scala)\n- [TypeScript](https://github.com/tree-sitter/tree-sitter-typescript)\n- [Verilog](https://github.com/tree-sitter/tree-sitter-verilog)\nNEWPARAGRAPH\nA list of known parsers can be found in the [wiki](https://github.com/tree-sitter/tree-sitter/wiki/List-of-parsers).\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/index.md","header":"Talks on Tree-sitter","text_blocks":["NEWPARAGRAPH\n- [Strange Loop 2018](https://www.thestrangeloop.com/2018/tree-sitter---a-new-parsing-system-for-programming-tools.html)\n- [FOSDEM 2018](https://www.youtube.com/watch?v=0CGzC_iss-8)\n- [GitHub Universe 2017](https://www.youtube.com/watch?v=a1rC79DHpmY)\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/index.md","header":"Underlying Research","text_blocks":["NEWPARAGRAPH\nThe design of Tree-sitter was greatly influenced by the following research papers:\nNEWPARAGRAPH\n- [Practical Algorithms for Incremental Software Development Environments](https://www2.eecs.berkeley.edu/Pubs/TechRpts/1997/CSD-97-946.pdf)\n- [Context Aware Scanning for Parsing Extensible Languages](https://www-users.cse.umn.edu/~evw/pubs/vanwyk07gpce/vanwyk07gpce.pdf)\n- [Efficient and Flexible Incremental Parsing](https://harmonia.cs.berkeley.edu/papers/twagner-parsing.pdf)\n- [Incremental Analysis of Real Programming Languages](https://harmonia.cs.berkeley.edu/papers/twagner-glr.pdf)\n- [Error Detection and Recovery in LR Parsers](https://web.archive.org/web/20240302031213/https://what-when-how.com/compiler-writing/bottom-up-parsing-compiler-writing-part-13)\n- [Error Recovery for LR Parsers](https://apps.dtic.mil/sti/pdfs/ADA043470.pdf)"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/build.md","header":"`tree-sitter build`","text_blocks":["NEWPARAGRAPH\nThe `build` command compiles your parser into a dynamically-loadable library,\neither as a shared object (`.so`, `.dylib`, or `.dll`) or as a WASM module.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nYou can change the compiler executable via the `CC` environment variable and add extra flags via `CFLAGS`.\nFor macOS or iOS, you can set `MACOSX_DEPLOYMENT_TARGET` or `IPHONEOS_DEPLOYMENT_TARGET` respectively to define the\nminimum supported version.\nNEWPARAGRAPH\nThe path argument allows you to specify the directory of the parser to build. If you don't supply this argument, the CLI\nwill attempt to build the parser in the current working directory.\nNEWPARAGRAPH\n"],"code_blocks":["\ntree-sitter build [OPTIONS] [PATH] # Aliases: b\n"]},{"file_path":"tree-sitter/docs/src/cli/build.md","header":"Options","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/build.md","header":"`-w/--wasm`","text_blocks":["NEWPARAGRAPH\nCompile the parser as a WASM module.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/build.md","header":"`-o/--output`","text_blocks":["NEWPARAGRAPH\nSpecify where to output the shared object file (native or WASM). This flag accepts either an absolute path or a relative\npath. If you don't supply this flag, the CLI will attempt to figure out what the language name is based on the parent\ndirectory name to use for the output file. If the CLI can't figure it out, it will default to `parser`, thus generating\n`parser.so` or `parser.wasm` in the current working directory.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/build.md","header":"`--reuse-allocator`","text_blocks":["NEWPARAGRAPH\nReuse the allocator that's set in the core library for the parser's external scanner. This is useful in applications\nwhere the author overrides the default allocator with their own, and wants to ensure every parser that allocates memory\nin the external scanner does so using their allocator.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/build.md","header":"`-0/--debug`","text_blocks":["NEWPARAGRAPH\nCompile the parser with debug flags enabled. This is useful when debugging issues that require a debugger like `gdb` or `lldb`."],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/highlight.md","header":"`tree-sitter highlight`","text_blocks":["NEWPARAGRAPH\nYou can run syntax highlighting on an arbitrary file using `tree-sitter highlight`. This can either output colors directly\nto your terminal using ANSI escape codes, or produce HTML (if the `--html` flag is passed). For more information, see\n[the syntax highlighting page](../3-syntax-highlighting.md).\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\ntree-sitter highlight [OPTIONS] [PATHS]... # Aliases: hi\n"]},{"file_path":"tree-sitter/docs/src/cli/highlight.md","header":"Options","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/highlight.md","header":"`-H/--html`","text_blocks":["NEWPARAGRAPH\nOutput an HTML document with syntax highlighting.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/highlight.md","header":"`--css-classes`","text_blocks":["NEWPARAGRAPH\nOutput HTML with CSS classes instead of inline styles.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/highlight.md","header":"`--check`","text_blocks":["NEWPARAGRAPH\nCheck that the highlighting captures conform strictly to the standards.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/highlight.md","header":"`--captures-path <CAPTURES_PATH>`","text_blocks":["NEWPARAGRAPH\nThe path to a file with captures. These captures would be considered the \"standard\" captures to compare against.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/highlight.md","header":"`--query-paths <QUERY_PATHS>`","text_blocks":["NEWPARAGRAPH\nThe paths to query files to use for syntax highlighting. These should end in `highlights.scm`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/highlight.md","header":"`--scope <SCOPE>`","text_blocks":["NEWPARAGRAPH\nThe language scope to use for syntax highlighting. This is useful when the language is ambiguous.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/highlight.md","header":"`-t/--time`","text_blocks":["NEWPARAGRAPH\nPrint the time taken to highlight the file.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/highlight.md","header":"`-q/--quiet`","text_blocks":["NEWPARAGRAPH\nSuppress main output.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/highlight.md","header":"`--paths <PATHS_FILE>`","text_blocks":["NEWPARAGRAPH\nThe path to a file that contains paths to source files to highlight\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/highlight.md","header":"`--config-path <CONFIG_PATH>`","text_blocks":["NEWPARAGRAPH\nThe path to an alternative configuration (`config.json`) file. See [the init-config command](./init-config.md) for more information.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/highlight.md","header":"`-n/--test-number <TEST_NUMBER>`","text_blocks":["NEWPARAGRAPH\nHighlight the contents of a specific test."],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/fuzz.md","header":"`tree-sitter fuzz`","text_blocks":["NEWPARAGRAPH\nThe `fuzz` command is used to fuzz a parser by performing random edits and ensuring that undoing these edits results in\nconsistent parse trees. It will fail if the parse trees are not equal, or if the changed ranges are inconsistent.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\ntree-sitter fuzz [OPTIONS] # Aliases: f\n"]},{"file_path":"tree-sitter/docs/src/cli/fuzz.md","header":"Options","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/fuzz.md","header":"`-s/--skip <SKIP>`","text_blocks":["NEWPARAGRAPH\nA list of test names to skip fuzzing.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/fuzz.md","header":"`--subdir <SUBDIR>`","text_blocks":["NEWPARAGRAPH\nThe directory containing the parser. This is primarily useful in multi-language repositories.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/fuzz.md","header":"`--edits <EDITS>`","text_blocks":["NEWPARAGRAPH\nThe maximum number of edits to perform. The default is 3.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/fuzz.md","header":"`--iterations <ITERATIONS>`","text_blocks":["NEWPARAGRAPH\nThe number of iterations to run. The default is 10.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/fuzz.md","header":"`-i/--include <INCLUDE>`","text_blocks":["NEWPARAGRAPH\nOnly run tests whose names match this regex.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/fuzz.md","header":"`-e/--exclude <EXCLUDE>`","text_blocks":["NEWPARAGRAPH\nSkip tests whose names match this regex.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/fuzz.md","header":"`--log-graphs`","text_blocks":["NEWPARAGRAPH\nOutputs logs of the graphs of the stack and parse trees during parsing, as well as the actual parsing and lexing message.\nThe graphs are constructed with [graphviz dot][dot], and the output is written to `log.html`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/fuzz.md","header":"`-l/--log`","text_blocks":["NEWPARAGRAPH\nOutputs parsing and lexing logs. This logs to stderr.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/fuzz.md","header":"`-r/--rebuild`","text_blocks":["NEWPARAGRAPH\nForce a rebuild of the parser before running the fuzzer.\nNEWPARAGRAPH\n[dot]: https://graphviz.org/doc/info/lang.html"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/tags.md","header":"`tree-sitter tags`","text_blocks":["NEWPARAGRAPH\nYou can run symbol tagging on an arbitrary file using `tree-sitter tags`. This will output a list of tags.\nFor more information, see [the code navigation page](../4-code-navigation.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/tags.md","header":"tagging-and-captures).","text_blocks":["NEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\ntree-sitter tags [OPTIONS] [PATHS]...\n"]},{"file_path":"tree-sitter/docs/src/cli/tags.md","header":"Options","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/tags.md","header":"`--scope <SCOPE>`","text_blocks":["NEWPARAGRAPH\nThe language scope to use for symbol tagging. This is useful when the language is ambiguous.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/tags.md","header":"`-t/--time`","text_blocks":["NEWPARAGRAPH\nPrint the time taken to generate tags for the file.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/tags.md","header":"`-q/--quiet`","text_blocks":["NEWPARAGRAPH\nSuppress main output.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/tags.md","header":"`--paths <PATHS_FILE>`","text_blocks":["NEWPARAGRAPH\nThe path to a file that contains paths to source files to tag.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/tags.md","header":"`--config-path <CONFIG_PATH>`","text_blocks":["NEWPARAGRAPH\nThe path to an alternative configuration (`config.json`) file. See [the init-config command](./init-config.md) for more information.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/tags.md","header":"`-n/--test-number <TEST_NUMBER>`","text_blocks":["NEWPARAGRAPH\nGenerate tags from the contents of a specific test."],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/complete.md","header":"`tree-sitter complete`","text_blocks":["NEWPARAGRAPH\nThe `complete` command generates a completion script for your shell.\nThis script can be used to enable autocompletion for the `tree-sitter` CLI.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\ntree-sitter complete --shell <SHELL> # Aliases: comp\n"]},{"file_path":"tree-sitter/docs/src/cli/complete.md","header":"Options","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/complete.md","header":"`--shell <SHELL>`","text_blocks":["NEWPARAGRAPH\nThe shell for which to generate the completion script.\nNEWPARAGRAPH\nSupported values: `bash`, `elvish`, `fish`, `power-shell`, `zsh`, and `nushell`."],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`tree-sitter parse`","text_blocks":["NEWPARAGRAPH\nThe `parse` command parses source files using a Tree-sitter parser. You can pass any number of file paths and glob patterns\nto `tree-sitter parse`, and it will parse all the given files. The command will exit with a non-zero status code if any\nparse errors occurred.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\ntree-sitter parse [OPTIONS] [PATHS]... # Aliases: p\n"]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"Options","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`--paths <PATHS_FILE>`","text_blocks":["NEWPARAGRAPH\nThe path to a file that contains paths to source files to parse.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`--scope <SCOPE>`","text_blocks":["NEWPARAGRAPH\nThe language scope to use for parsing. This is useful when the language is ambiguous.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`-d/--debug`","text_blocks":["NEWPARAGRAPH\nOutputs parsing and lexing logs. This logs to stderr.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`-0/--debug-build`","text_blocks":["NEWPARAGRAPH\nCompile the parser with debug flags enabled. This is useful when debugging issues that require a debugger like `gdb` or `lldb`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`-D/--debug-graph`","text_blocks":["NEWPARAGRAPH\nOutputs logs of the graphs of the stack and parse trees during parsing, as well as the actual parsing and lexing message.\nThe graphs are constructed with [graphviz dot][dot], and the output is written to `log.html`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`--wasm`","text_blocks":["NEWPARAGRAPH\nCompile and run the parser as a WASM module.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`--dot`","text_blocks":["NEWPARAGRAPH\nOutput the parse tree with [graphviz dot][dot].\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`-x/--xml`","text_blocks":["NEWPARAGRAPH\nOutput the parse tree in XML format.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`-c/--cst`","text_blocks":["NEWPARAGRAPH\nOutput the parse tree in a pretty-printed CST format.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`-s/--stat`","text_blocks":["NEWPARAGRAPH\nShow parsing statistics.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`--timeout <TIMEOUT>`","text_blocks":["NEWPARAGRAPH\nSet the timeout for parsing a single file, in microseconds.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`-t/--time`","text_blocks":["NEWPARAGRAPH\nPrint the time taken to parse the file. If edits are provided, this will also print the time taken to parse the file after\neach edit.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`-q/--quiet`","text_blocks":["NEWPARAGRAPH\nSuppress main output.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`--edits <EDITS>...`","text_blocks":["NEWPARAGRAPH\nApply edits after parsing the file. Edits are in the form of `row,col|position delcount insert_text` where row and col, or position are 0-indexed.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`--encoding <ENCODING>`","text_blocks":["NEWPARAGRAPH\nSet the encoding of the input file. By default, the CLI will look for the [`BOM`][bom] to determine if the file is encoded\nin `UTF-16BE` or `UTF-16LE`. If no `BOM` is present, `UTF-8` is the default. One of `utf8`, `utf16-le`, `utf16-be`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`--open-log`","text_blocks":["NEWPARAGRAPH\nWhen using the `--debug-graph` option, open the log file in the default browser.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`--config-path <CONFIG_PATH>`","text_blocks":["NEWPARAGRAPH\nThe path to an alternative configuration (`config.json`) file. See [the init-config command](./init-config.md) for more information.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`-n/--test-number <TEST_NUMBER>`","text_blocks":["NEWPARAGRAPH\nParse a specific test in the corpus. The test number is the same number that appears in the output of `tree-sitter test`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`-r/--rebuild`","text_blocks":["NEWPARAGRAPH\nForce a rebuild of the parser before running tests.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/parse.md","header":"`--no-ranges`","text_blocks":["NEWPARAGRAPH\nOmit the node's ranges from the default parse output. This is useful when copying S-Expressions to a test file.\nNEWPARAGRAPH\n[dot]: https://graphviz.org/doc/info/lang.html\n[bom]: https://en.wikipedia.org/wiki/Byte_order_mark"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/playground.md","header":"`tree-sitter playground`","text_blocks":["NEWPARAGRAPH\nThe `playground` command allows you to start a local playground to test your parser interactively.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\ntree-sitter playground [OPTIONS] # Aliases: play, pg, web-ui\n","\nFor this to work, you must have already built the parser as a WASM module. This can be done with the [`build`](./build.md) subcommand\n(`tree-sitter build --wasm`).\n"]},{"file_path":"tree-sitter/docs/src/cli/playground.md","header":"Options","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/playground.md","header":"`-q/--quiet`","text_blocks":["NEWPARAGRAPH\nDon't automatically open the playground in the default browser.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/playground.md","header":"`--grammar-path <GRAMMAR_PATH>`","text_blocks":["NEWPARAGRAPH\nThe path to the directory containing the grammar and wasm files."],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"`tree-sitter init`","text_blocks":["NEWPARAGRAPH\nThe `init` command is your starting point for creating a new grammar. When you run it, it sets up a repository with all\nthe essential files and structure needed for grammar development. Since the command includes git-related files by default,\nwe recommend using git for version control of your grammar.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\ntree-sitter init [OPTIONS] # Aliases: i\n"]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"Options","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"`--update`","text_blocks":["NEWPARAGRAPH\nUpdate outdated generated files, if needed.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"Structure of `tree-sitter.json`","text_blocks":["NEWPARAGRAPH\nThe main file of interest for users to configure is `tree-sitter.json`, which tells the CLI information about your grammar,\nsuch as the location of queries.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"The `grammars` field","text_blocks":["NEWPARAGRAPH\nThis field is an array of objects, though you typically only need one object in this array unless your repo has\nmultiple grammars (for example, `Typescript` and `TSX`).\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"Example","text_blocks":["NEWPARAGRAPH\nTypically, the objects in the `\"tree-sitter\"` array only needs to specify a few keys:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n{\n  \"tree-sitter\": [\n    {\n      \"scope\": \"source.ruby\",\n      \"file-types\": [\n        \"rb\",\n        \"gemspec\",\n        \"Gemfile\",\n        \"Rakefile\"\n      ],\n      \"first-line-regex\": \"#!.*\\\\bruby$\"\n    }\n  ]\n}\n"]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"Basic Fields","text_blocks":["NEWPARAGRAPH\nThese keys specify basic information about the parser:\nNEWPARAGRAPH\n- `scope` (required) — A string like `\"source.js\"` that identifies the language.\nWe strive to match the scope names used by popular [TextMate grammars][textmate] and by the [Linguist][linguist] library.\nNEWPARAGRAPH\n- `path` — A relative path from the directory containing `tree-sitter.json` to another directory containing the `src/`\nfolder, which contains the actual generated parser. The default value is `\".\"`\n(so that `src/` is in the same folder as `tree-sitter.json`), and this very rarely needs to be overridden.\nNEWPARAGRAPH\n- `external-files` — A list of relative paths from the root dir of a\nparser to files that should be checked for modifications during recompilation.\nThis is useful during development to have changes to other files besides scanner.c\nbe picked up by the cli.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"Language Detection","text_blocks":["NEWPARAGRAPH\nThese keys help to decide whether the language applies to a given file:\nNEWPARAGRAPH\n- `file-types` — An array of filename suffix strings. The grammar will be used for files whose names end with one of\nthese suffixes. Note that the suffix may match an *entire* filename.\nNEWPARAGRAPH\n- `first-line-regex` — A regex pattern that will be tested against the first line of a file\nto determine whether this language applies to the file. If present, this regex will be used for any file whose\nlanguage does not match any grammar's `file-types`.\nNEWPARAGRAPH\n- `content-regex` — A regex pattern that will be tested against the contents of the file\nto break ties in cases where multiple grammars matched the file using the above two criteria. If the regex matches,\nthis grammar will be preferred over another grammar with no `content-regex`. If the regex does not match, a grammar with\nno `content-regex` will be preferred over this one.\nNEWPARAGRAPH\n- `injection-regex` — A regex pattern that will be tested against a *language name* to determine whether this language\nshould be used for a potential *language injection* site.\nLanguage injection is described in more detail in [the relevant section](../3-syntax-highlighting.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"language-injection).","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"Query Paths","text_blocks":["NEWPARAGRAPH\nThese keys specify relative paths from the directory containing `tree-sitter.json` to the files that control syntax highlighting:\nNEWPARAGRAPH\n- `highlights` — Path to a *highlight query*. Default: `queries/highlights.scm`\n- `locals` — Path to a *local variable query*. Default: `queries/locals.scm`.\n- `injections` — Path to an *injection query*. Default: `queries/injections.scm`.\n- `tags` — Path to an *tag query*. Default: `queries/tags.scm`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"The `metadata` field","text_blocks":["NEWPARAGRAPH\nThis field contains information that tree-sitter will use to populate relevant bindings' files, especially their versions.\nTypically, this will all be set up when you run `tree-sitter init`, but you are welcome to update it as you see fit.\nNEWPARAGRAPH\n- `version` (required) — The current version of your grammar, which should follow [semver][semver]\n- `license` — The license of your grammar, which should be a valid [SPDX license][spdx]\n- `description` — The brief description of your grammar\n- `authors` (required) — An array of objects that contain a `name` field, and optionally an `email` and `url` field.\nEach field is a string\n- `links` — An object that contains a `repository` field, and optionally a `homepage` field. Each field is a string\n- `namespace` — The namespace for the `Java` and `Kotlin` bindings, defaults to `io.github.tree-sitter` if not provided\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"The `bindings` field","text_blocks":["NEWPARAGRAPH\nThis field controls what bindings are generated when the `init` command is run.\nEach key is a language name, and the value is a boolean.\nNEWPARAGRAPH\n- `c` (default: `true`)\n- `go` (default: `true`)\n- `java` (default: `false`)\n- `kotlin` (default: `false`)\n- `node` (default: `true`)\n- `python` (default: `true`)\n- `rust` (default: `true`)\n- `swift` (default: `false`)\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"Binding Files","text_blocks":["NEWPARAGRAPH\nWhen you run `tree-sitter init`, the CLI will also generate a number of files in your repository that allow for your parser\nto be used from different language. Here is a list of these bindings files that are generated, and what their purpose is:\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"C/C++","text_blocks":["NEWPARAGRAPH\n- `Makefile` — This file tells [`make`][make] how to compile your language.\n- `CMakeLists.txt` — This file tells [`cmake`][cmake] how to compile your language.\n- `bindings/c/tree_sitter/tree-sitter-language.h` — This file provides the C interface of your language.\n- `bindings/c/tree-sitter-language.pc` — This file provides [pkg-config][pkg-config] metadata about your language's C library.\n- `src/tree_sitter/parser.h` — This file provides some basic C definitions that are used in your generated `parser.c` file.\n- `src/tree_sitter/alloc.h` — This file provides some memory allocation macros that are to be used in your external scanner,\nif you have one.\n- `src/tree_sitter/array.h` — This file provides some array macros that are to be used in your external scanner,\nif you have one.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"Go","text_blocks":["NEWPARAGRAPH\n- `go.mod` — This file is the manifest of the Go module.\n- `bindings/go/binding.go` — This file wraps your language in a Go module.\n- `bindings/go/binding_test.go` — This file contains a test for the Go package.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"Node","text_blocks":["NEWPARAGRAPH\n- `binding.gyp` — This file tells Node.js how to compile your language.\n- `package.json` — This file is the manifest of the Node.js package.\n- `bindings/node/binding.cc` — This file wraps your language in a JavaScript module for Node.js.\n- `bindings/node/index.js` — This is the file that Node.js initially loads when using your language.\n- `bindings/node/index.d.ts` — This file provides type hints for your parser when used in TypeScript.\n- `bindings/node/binding_test.js` — This file contains a test for the Node.js package.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"Python","text_blocks":["NEWPARAGRAPH\n- `pyproject.toml` — This file is the manifest of the Python package.\n- `setup.py` — This file tells Python how to compile your language.\n- `bindings/python/tree_sitter_language/binding.c` — This file wraps your language in a Python module.\n- `bindings/python/tree_sitter_language/__init__.py` — This file tells Python how to load your language.\n `bindings/python/tree_sitter_language/__init__.pyi` — This file provides type hints for your parser when used in Python.\n- `bindings/python/tree_sitter_language/py.typed` — This file provides type hints for your parser when used in Python.\n- `bindings/python/tests/test_binding.py` — This file contains a test for the Python package.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"Rust","text_blocks":["NEWPARAGRAPH\n- `Cargo.toml` — This file is the manifest of the Rust package.\n- `bindings/rust/lib.rs` — This file wraps your language in a Rust crate when used in Rust.\n- `bindings/rust/build.rs` — This file wraps the building process for the Rust crate.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"Swift","text_blocks":["NEWPARAGRAPH\n- `Package.swift` — This file tells Swift how to compile your language.\n- `bindings/swift/TreeSitterLanguage/language.h` — This file wraps your language in a Swift module when used in Swift.\n- `bindings/swift/TreeSitterLanguageTests/TreeSitterLanguageTests.swift` — This file contains a test for the Swift package.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init.md","header":"Additional Files","text_blocks":["NEWPARAGRAPH\nAdditionally, there's a few other files that are generated when you run `tree-sitter init`,\nthat aim to improve the development experience:\nNEWPARAGRAPH\n- `.editorconfig` — This file tells your editor how to format your code. More information about this file can be found [here][editorconfig]\n- `.gitattributes` — This file tells Git how to handle line endings, and tells GitHub what files are generated.\n- `.gitignore` — This file tells Git what files to ignore when committing changes.\nNEWPARAGRAPH\n[cmake]: https://cmake.org/cmake/help/latest\n[editorconfig]: https://editorconfig.org\n[linguist]: https://github.com/github/linguist\n[make]: https://www.gnu.org/software/make/manual/make.html\n[pkg-config]: https://www.freedesktop.org/wiki/Software/pkg-config\n[semver]: https://semver.org\n[spdx]: https://spdx.org/licenses\n[textmate]: https://macromates.com/manual/en/language_grammars"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/index.md","header":"CLI Overview","text_blocks":["NEWPARAGRAPH\nLet's go over all of the functionality of the `tree-sitter` command line interface.\nOnce you feel that you have enough of a grasp on the CLI, you can move onto the grammar authoring section to learn more about writing your own parser."],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/version.md","header":"`tree-sitter version`","text_blocks":["NEWPARAGRAPH\nThe `version` command upgrades the version of your grammar.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis will update the version in several files, if they exist:\nNEWPARAGRAPH\n* tree-sitter.json\n* Cargo.toml\n* Cargo.lock\n* package.json\n* package-lock.json\n* Makefile\n* CMakeLists.txt\n* pyproject.toml\nNEWPARAGRAPH\nAs a grammar author, you should keep the version of your grammar in sync across\ndifferent bindings. However, doing so manually is error-prone and tedious, so\nthis command takes care of the burden. If you are using a version control system,\nit is recommended to commit the changes made by this command, and to tag the\ncommit with the new version."],"code_blocks":["\ntree-sitter version <VERSION> # Aliases: publish\n"]},{"file_path":"tree-sitter/docs/src/cli/generate.md","header":"`tree-sitter generate`","text_blocks":["NEWPARAGRAPH\nThe most important command you'll use is `tree-sitter generate`. This command reads the `grammar.js` file in your current\nworking directory and creates a file called `src/parser.c`, which implements the parser. After making changes to your grammar,\njust run `tree-sitter generate` again.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThe grammar path argument allows you to specify a path to a `grammar.js` JavaScript file, or `grammar.json` JSON file.\nIn case your `grammar.js` file is in a non-standard path, you can specify it yourself. But, if you are using a parser\nwhere `grammar.json` was already generated, or it was hand-written, you can tell the CLI to generate the parser *based*\non this JSON file. This avoids relying on a JavaScript file and avoids the dependency on a JavaScript runtime.\nNEWPARAGRAPH\nIf there is an ambiguity or *local ambiguity* in your grammar, Tree-sitter will detect it during parser generation, and\nit will exit with a `Unresolved conflict` error message. To learn more about conflicts and how to handle them, check out\nthe section on [`Structuring Rules Well`](../creating-parsers/3-writing-the-grammar.md"],"code_blocks":["\ntree-sitter generate [OPTIONS] [GRAMMAR_PATH] # Aliases: gen, g\n"]},{"file_path":"tree-sitter/docs/src/cli/generate.md","header":"structuring-rules-well)","text_blocks":["in the user guide.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/generate.md","header":"Options","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/generate.md","header":"`-l/--log`","text_blocks":["NEWPARAGRAPH\nPrint the log of the parser generation process. This is really only useful if you know what you're doing, or are investigating\na bug in the CLI itself. It logs info such as what tokens are included in the error recovery state,\nwhat keywords were extracted, what states were split and why, and the entry point state.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/generate.md","header":"`--abi <VERSION>`","text_blocks":["NEWPARAGRAPH\nThe ABI to use for parser generation. The default is ABI 15, with ABI 14 being a supported target.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/generate.md","header":"`-b/--build`","text_blocks":["NEWPARAGRAPH\nCompile all defined languages in the current directory. The cli will automatically compile the parsers after generation,\nand place them in the cache dir.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/generate.md","header":"`-0/--debug-build`","text_blocks":["NEWPARAGRAPH\nCompile the parser with debug flags enabled. This is useful when debugging issues that require a debugger like `gdb` or `lldb`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/generate.md","header":"`--libdir <PATH>`","text_blocks":["NEWPARAGRAPH\nThe directory to place the compiled parser(s) in.\nOn Unix systems, the default path is `$XDG_CACHE_HOME/tree-sitter` if `$XDG_CACHE_HOME` is set,\notherwise `$HOME/.config/tree-sitter` is used. On Windows, the default path is `%LOCALAPPDATA%\\tree-sitter` if available,\notherwise `$HOME\\AppData\\Local\\tree-sitter` is used.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/generate.md","header":"`-o/--output`","text_blocks":["NEWPARAGRAPH\nThe directory to place the generated parser in. The default is `src/` in the current directory.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/generate.md","header":"`--report-states-for-rule <RULE>`","text_blocks":["NEWPARAGRAPH\nPrint the overview of states from the given rule. This is useful for debugging and understanding the generated parser's\nitem sets for all given states in a given rule. To solely view state count numbers for rules, pass in `-` for the rule argument.\nTo view the overview of states for every rule, pass in `*` for the rule argument.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/generate.md","header":"`--js-runtime <EXECUTABLE>`","text_blocks":["NEWPARAGRAPH\nThe path to the JavaScript runtime executable to use when generating the parser. The default is `node`.\nNote that you can also set this with `TREE_SITTER_JS_RUNTIME`."],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init-config.md","header":"`tree-sitter init-config`","text_blocks":["NEWPARAGRAPH\nThis command initializes a configuration file for the Tree-sitter CLI.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThese directories are created in the \"default\" location for your platform:\nNEWPARAGRAPH\n* On Unix, `$XDG_CONFIG_HOME/tree-sitter` or `$HOME/.config/tree-sitter`\n* On Windows, `%APPDATA%\\tree-sitter` or `$HOME\\AppData\\Roaming\\tree-sitter`\nNEWPARAGRAPH\n","NEWPARAGRAPH\nWhen you run the `init-config` command, it will print out the location of the file that it creates so that you can easily\nfind and modify it.\nNEWPARAGRAPH\nThe configuration file is a JSON file that contains the following fields:\nNEWPARAGRAPH\n"],"code_blocks":["\ntree-sitter init-config\n","\nThe CLI will work if there's no config file present, falling back on default values for each configuration option.\n"]},{"file_path":"tree-sitter/docs/src/cli/init-config.md","header":"`parser-directories`","text_blocks":["NEWPARAGRAPH\nThe [`tree-sitter highlight`](./highlight.md) command takes one or more file paths, and tries to automatically determine,\nwhich language should be used to highlight those files. To do this, it needs to know *where* to look for Tree-sitter grammars\non your filesystem. You can control this using the `\"parser-directories\"` key in your configuration file:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nAny folder within one of these *parser directories* whose name begins with `tree-sitter-` will be treated as a Tree-sitter\ngrammar repository.\nNEWPARAGRAPH\n"],"code_blocks":["\n{\n  \"parser-directories\": [\n    \"/Users/my-name/code\",\n    \"/Users/my-name/other-code\"\n  ]\n}\n"]},{"file_path":"tree-sitter/docs/src/cli/init-config.md","header":"`theme`","text_blocks":["NEWPARAGRAPH\nThe [Tree-sitter highlighting system](../3-syntax-highlighting.md) works by annotating ranges of source code with logical\n\"highlight names\" like `function.method`, `type.builtin`, `keyword`, etc. To decide what *color* should be used for rendering\neach highlight, a *theme* is needed.\nNEWPARAGRAPH\nIn your config file, the `\"theme\"` value is an object whose keys are dot-separated highlight names like\n`function.builtin` or `keyword`, and whose values are JSON expressions that represent text styling parameters.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init-config.md","header":"Highlight Names","text_blocks":["NEWPARAGRAPH\nA theme can contain multiple keys that share a common subsequence. Examples:\nNEWPARAGRAPH\n* `variable` and `variable.parameter`\n* `function`, `function.builtin`, and `function.method`\nNEWPARAGRAPH\nFor a given highlight produced, styling will be determined based on the **longest matching theme key**. For example, the\nhighlight `function.builtin.static` would match the key `function.builtin` rather than `function`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init-config.md","header":"Styling Values","text_blocks":["NEWPARAGRAPH\nStyling values can be any of the following:\nNEWPARAGRAPH\n* Integers from 0 to 255, representing ANSI terminal color ids.\n* Strings like `\""],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/init-config.md","header":"e45649\"` representing hexadecimal RGB colors.","text_blocks":["* Strings naming basic ANSI colors like `\"red\"`, `\"black\"`, `\"purple\"`, or `\"cyan\"`.\n* Objects with the following keys:\n  * `color` — An integer or string as described above.\n  * `underline` — A boolean indicating whether the text should be underlined.\n  * `italic` — A boolean indicating whether the text should be italicized.\n  * `bold` — A boolean indicating whether the text should be bold-face.\nNEWPARAGRAPH\nAn example theme can be seen below:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n{\n  \"function\": 26,\n  \"operator\": {\n    \"bold\": true,\n    \"color\": 239\n  },\n  \"variable.builtin\": {\n    \"bold\": true\n  },\n  \"variable.parameter\": {\n    \"underline\": true\n  },\n  \"type.builtin\": {\n    \"color\": 23,\n    \"bold\": true\n  },\n  \"keyword\": 56,\n  \"type\": 23,\n  \"number\": {\n    \"bold\": true,\n    \"color\": 94\n  },\n  \"constant\": 94,\n  \"attribute\": {\n    \"color\": 124,\n    \"italic\": true\n  },\n  \"comment\": {\n    \"color\": 245,\n    \"italic\": true\n  },\n  \"constant.builtin\": {\n    \"color\": 94,\n    \"bold\": true\n  },\n}\n"]},{"file_path":"tree-sitter/docs/src/cli/init-config.md","header":"`parse-theme`","text_blocks":["NEWPARAGRAPH\nThe [`tree-sitter parse`](./parse.md) command will output a pretty-printed CST when the `-c/--cst` option is used. You can\ncontrol what colors are used for various parts of the tree in your configuration file.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nAn example parse theme can be seen below:\nNEWPARAGRAPH\n"],"code_blocks":["\nOmitting a field will cause the relevant text to be rendered with its default color.\n","\n{\n  \"parse-theme\": {\n    // The color of node kinds\n    \"node-kind\": [20, 20, 20],\n    // The color of text associated with a node\n    \"node-text\": [255, 255, 255],\n    // The color of node fields\n    \"field\": [42, 42, 42],\n    // The color of the range information for unnamed nodes\n    \"row-color\": [255, 255, 255],\n    // The color of the range information for named nodes\n    \"row-color-named\": [255, 130, 0],\n    // The color of extra nodes\n    \"extra\": [255, 0, 255],\n    // The color of ERROR nodes\n    \"error\": [255, 0, 0],\n    // The color of MISSING nodes and their associated text\n    \"missing\": [153, 75, 0],\n    // The color of newline characters\n    \"line-feed\": [150, 150, 150],\n    // The color of backtick characters\n    \"backtick\": [0, 200, 0],\n    // The color of literals\n    \"literal\": [0, 0, 200],\n  }\n}\n"]},{"file_path":"tree-sitter/docs/src/cli/test.md","header":"`tree-sitter test`","text_blocks":["NEWPARAGRAPH\nThe `test` command is used to run the test suite for a parser.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\ntree-sitter test [OPTIONS] # Aliases: t\n"]},{"file_path":"tree-sitter/docs/src/cli/test.md","header":"Options","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/test.md","header":"`-i/--include <INCLUDE>`","text_blocks":["NEWPARAGRAPH\nOnly run tests whose names match this regex.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/test.md","header":"`-e/--exclude <EXCLUDE>`","text_blocks":["NEWPARAGRAPH\nSkip tests whose names match this regex.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/test.md","header":"`-u/--update`","text_blocks":["NEWPARAGRAPH\nUpdate the expected output of tests.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\nTests containing `ERROR` nodes or `MISSING` nodes will not be updated.\n"]},{"file_path":"tree-sitter/docs/src/cli/test.md","header":"`-d/--debug`","text_blocks":["NEWPARAGRAPH\nOutputs parsing and lexing logs. This logs to stderr.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/test.md","header":"`-0/--debug-build`","text_blocks":["NEWPARAGRAPH\nCompile the parser with debug flags enabled. This is useful when debugging issues that require a debugger like `gdb` or `lldb`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/test.md","header":"`-D/--debug-graph`","text_blocks":["NEWPARAGRAPH\nOutputs logs of the graphs of the stack and parse trees during parsing, as well as the actual parsing and lexing message.\nThe graphs are constructed with [graphviz dot][dot], and the output is written to `log.html`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/test.md","header":"`--wasm`","text_blocks":["NEWPARAGRAPH\nCompile and run the parser as a WASM module.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/test.md","header":"`--open-log`","text_blocks":["NEWPARAGRAPH\nWhen using the `--debug-graph` option, open the log file in the default browser.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/test.md","header":"`--config-path <CONFIG_PATH>`","text_blocks":["NEWPARAGRAPH\nThe path to an alternative configuration (`config.json`) file. See [the init-config command](./init-config.md) for more information.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/test.md","header":"`--show-fields`","text_blocks":["NEWPARAGRAPH\nForce showing fields in test diffs.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/test.md","header":"`--stat <STAT>`","text_blocks":["NEWPARAGRAPH\nShow parsing statistics when tests are being run. One of `all`, `outliers-and-total`, or `total-only`.\nNEWPARAGRAPH\n- `all`: Show statistics for every test.\nNEWPARAGRAPH\n- `outliers-and-total`: Show statistics only for outliers, and total statistics.\nNEWPARAGRAPH\n- `total-only`: Show only total statistics.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/test.md","header":"`-r/--rebuild`","text_blocks":["NEWPARAGRAPH\nForce a rebuild of the parser before running tests.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/test.md","header":"`--overview-only`","text_blocks":["NEWPARAGRAPH\nOnly show the overview of the test results, and not the diff."],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/query.md","header":"`tree-sitter query`","text_blocks":["NEWPARAGRAPH\nThe `query` command is used to run a query on a parser, and view the results.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\ntree-sitter query [OPTIONS] <QUERY_PATH> [PATHS]... # Aliases: q\n"]},{"file_path":"tree-sitter/docs/src/cli/query.md","header":"Options","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/query.md","header":"`-t/--time`","text_blocks":["NEWPARAGRAPH\nPrint the time taken to execute the query on the file.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/query.md","header":"`-q/--quiet`","text_blocks":["NEWPARAGRAPH\nSuppress main output.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/query.md","header":"`--paths <PATHS_FILE>`","text_blocks":["NEWPARAGRAPH\nThe path to a file that contains paths to source files in which the query will be executed.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/query.md","header":"`--byte-range <BYTE_RANGE>`","text_blocks":["NEWPARAGRAPH\nThe range of byte offsets in which the query will be executed. The format is `start_byte:end_byte`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/query.md","header":"`--row-range <ROW_RANGE>`","text_blocks":["NEWPARAGRAPH\nThe range of rows in which the query will be executed. The format is `start_row:end_row`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/query.md","header":"`--scope <SCOPE>`","text_blocks":["NEWPARAGRAPH\nThe language scope to use for parsing and querying. This is useful when the language is ambiguous.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/query.md","header":"`-c/--captures`","text_blocks":["NEWPARAGRAPH\nOrder the query results by captures instead of matches.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/query.md","header":"`--test`","text_blocks":["NEWPARAGRAPH\nWhether to run query tests or not.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/query.md","header":"`--config-path <CONFIG_PATH>`","text_blocks":["NEWPARAGRAPH\nThe path to an alternative configuration (`config.json`) file. See [the init-config command](./init-config.md) for more information.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/query.md","header":"`-n/--test-number <TEST_NUMBER>`","text_blocks":["NEWPARAGRAPH\nQuery the contents of a specific test."],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/dump-languages.md","header":"`tree-sitter dump-languages`","text_blocks":["NEWPARAGRAPH\nThe `dump-languages` command prints out a list of all the languages that the CLI knows about. This can be useful for debugging purposes, or for scripting. The paths to search comes from the config file's [`parser-directories`][parser-directories] object.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\ntree-sitter dump-languages [OPTIONS] # Aliases: langs\n"]},{"file_path":"tree-sitter/docs/src/cli/dump-languages.md","header":"Options","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/dump-languages.md","header":"`--config-path`","text_blocks":["NEWPARAGRAPH\nThe path to the configuration file. Ordinarily, the CLI will use the default location as explained in the [init-config](./init-config.md) command. This flag allows you to explicitly override that default, and use a config defined elsewhere.\nNEWPARAGRAPH\n[parser-directories]: ./init-config.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/cli/dump-languages.md","header":"parser-directories","text_blocks":[],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/4-external-scanners.md","header":"External Scanners","text_blocks":["NEWPARAGRAPH\nMany languages have some tokens whose structure is impossible or inconvenient to describe with a regular expression.\nSome examples:\nNEWPARAGRAPH\n- [Indent and dedent][indent-tokens] tokens in Python\n- [Heredocs][heredoc] in Bash and Ruby\n- [Percent strings][percent-string] in Ruby\nNEWPARAGRAPH\nTree-sitter allows you to handle these kinds of tokens using _external scanners_. An external scanner is a set of C functions\nthat you, the grammar author, can write by hand to add custom logic for recognizing certain tokens.\nNEWPARAGRAPH\nTo use an external scanner, there are a few steps. First, add an `externals` section to your grammar. This section should\nlist the names of all of your external tokens. These names can then be used elsewhere in your grammar.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThen, add another C source file to your project. Its path must be src/scanner.c for the CLI to recognize it. Be sure to add\nthis file to the sources section of your `binding.gyp` file so that it will be included when your project is compiled by\nNode.js and uncomment the appropriate block in your bindings/rust/build.rs file so that it will be included in your Rust\ncrate.\nNEWPARAGRAPH\nIn this new source file, define an [`enum`][enum] type containing the names of all of your external tokens. The ordering\nof this enum must match the order in your grammar's `externals` array; the actual names do not matter.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nFinally, you must define five functions with specific names, based on your language's name and five actions:\n_create_, _destroy_, _serialize_, _deserialize_, and _scan_.\nNEWPARAGRAPH\n"],"code_blocks":["\ngrammar({\n  name: \"my_language\",\nNEWPARAGRAPH\n  externals: $ => [$.indent, $.dedent, $.newline],\nNEWPARAGRAPH\n  // ...\n});\n","\n#include \"tree_sitter/parser.h\"\n#include \"tree_sitter/alloc.h\"\n#include \"tree_sitter/array.h\"\nNEWPARAGRAPH\nenum TokenType {\n  INDENT,\n  DEDENT,\n  NEWLINE\n}\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/4-external-scanners.md","header":"Create","text_blocks":["NEWPARAGRAPH\n","NEWPARAGRAPH\nThis function should create your scanner object. It will only be called once anytime your language is set on a parser.\nOften, you will want to allocate memory on the heap and return a pointer to it. If your external scanner doesn't need to\nmaintain any state, it's ok to return `NULL`.\nNEWPARAGRAPH\n"],"code_blocks":["\nvoid * tree_sitter_my_language_external_scanner_create() {\n  // ...\n}\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/4-external-scanners.md","header":"Destroy","text_blocks":["NEWPARAGRAPH\n","NEWPARAGRAPH\nThis function should free any memory used by your scanner. It is called once when a parser is deleted or assigned a different\nlanguage. It receives as an argument the same pointer that was returned from the _create_ function. If your _create_ function\ndidn't allocate any memory, this function can be a no-op.\nNEWPARAGRAPH\n"],"code_blocks":["\nvoid tree_sitter_my_language_external_scanner_destroy(void *payload) {\n  // ...\n}\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/4-external-scanners.md","header":"Serialize","text_blocks":["NEWPARAGRAPH\n","NEWPARAGRAPH\nThis function should copy the complete state of your scanner into a given byte buffer, and return the number of bytes written.\nThe function is called every time the external scanner successfully recognizes a token. It receives a pointer to your scanner\nand a pointer to a buffer. The maximum number of bytes that you can write is given by the `TREE_SITTER_SERIALIZATION_BUFFER_SIZE`\nconstant, defined in the `tree_sitter/parser.h` header file.\nNEWPARAGRAPH\nThe data that this function writes will ultimately be stored in the syntax tree so that the scanner can be restored to the\nright state when handling edits or ambiguities. For your parser to work correctly, the `serialize` function must store its\nentire state, and `deserialize` must restore the entire state. For good performance, you should design your scanner so that\nits state can be serialized as quickly and compactly as possible.\nNEWPARAGRAPH\n"],"code_blocks":["\nunsigned tree_sitter_my_language_external_scanner_serialize(\n  void *payload,\n  char *buffer\n) {\n  // ...\n}\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/4-external-scanners.md","header":"Deserialize","text_blocks":["NEWPARAGRAPH\n","NEWPARAGRAPH\nThis function should _restore_ the state of your scanner based the bytes that were previously written by the `serialize`\nfunction. It is called with a pointer to your scanner, a pointer to the buffer of bytes, and the number of bytes that should\nbe read. It is good practice to explicitly erase your scanner state variables at the start of this function, before restoring\ntheir values from the byte buffer.\nNEWPARAGRAPH\n"],"code_blocks":["\nvoid tree_sitter_my_language_external_scanner_deserialize(\n  void *payload,\n  const char *buffer,\n  unsigned length\n) {\n  // ...\n}\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/4-external-scanners.md","header":"Scan","text_blocks":["NEWPARAGRAPH\nTypically, one will\nNEWPARAGRAPH\n- Call `lexer->advance` several times, if the characters are valid for the token being lexed.\nNEWPARAGRAPH\n- Optionally, call `lexer->mark_end` to mark the end of the token, and \"peek ahead\"\nto check if the next character (or set of characters) invalidates the token.\nNEWPARAGRAPH\n- Set `lexer->result_symbol` to the token type.\nNEWPARAGRAPH\n- Return `true` from the scanning function, indicating that a token was successfully lexed.\nNEWPARAGRAPH\nTree-sitter will then push resulting node to the parse stack, and the input position will remain where it reached at the\npoint `lexer->mark_end` was called.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThe second parameter to this function is the lexer, of type `TSLexer`. The `TSLexer` struct has the following fields:\nNEWPARAGRAPH\n- **`int32_t lookahead`** — The current next character in the input stream, represented as a 32-bit unicode code point.\nNEWPARAGRAPH\n- **`TSSymbol result_symbol`** — The symbol that was recognized. Your scan function should _assign_ to this field one of\nthe values from the `TokenType` enum, described above.\nNEWPARAGRAPH\n- **`void (*advance)(TSLexer *, bool skip)`** — A function for advancing to the next character. If you pass `true` for\nthe second argument, the current character will be treated as whitespace; whitespace won't be included in the text range\nassociated with tokens emitted by the external scanner.\nNEWPARAGRAPH\n- **`void (*mark_end)(TSLexer *)`** — A function for marking the end of the recognized token. This allows matching tokens\nthat require multiple characters of lookahead. By default, (if you don't call `mark_end`), any character that you moved past\nusing the `advance` function will be included in the size of the token. But once you call `mark_end`, then any later calls\nto `advance` will _not_ increase the size of the returned token. You can call `mark_end` multiple times to increase the size\nof the token.\nNEWPARAGRAPH\n- **`uint32_t (*get_column)(TSLexer *)`** — A function for querying the current column position of the lexer. It returns\nthe number of codepoints since the start of the current line. The codepoint position is recalculated on every call to this\nfunction by reading from the start of the line.\nNEWPARAGRAPH\n- **`bool (*is_at_included_range_start)(const TSLexer *)`** — A function for checking whether the parser has just skipped\nsome characters in the document. When parsing an embedded document using the `ts_parser_set_included_ranges` function\n(described in the [multi-language document section][multi-language-section]), the scanner may want to apply some special\nbehavior when moving to a disjoint part of the document. For example, in [EJS documents][ejs], the JavaScript parser uses\nthis function to enable inserting automatic semicolon tokens in between the code directives, delimited by `<%` and `%>`.\nNEWPARAGRAPH\n- **`bool (*eof)(const TSLexer *)`** — A function for determining whether the lexer is at the end of the file. The value\nof `lookahead` will be `0` at the end of a file, but this function should be used instead of checking for that value because\nthe `0` or \"NUL\" value is also a valid character that could be present in the file being parsed.\nNEWPARAGRAPH\nThe third argument to the `scan` function is an array of booleans that indicates which of external tokens are expected by\nthe parser. You should only look for a given token if it is valid according to this array. At the same time, you cannot\nbacktrack, so you may need to combine certain pieces of logic.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\nbool tree_sitter_my_language_external_scanner_scan(\n  void *payload,\n  TSLexer *lexer,\n  const bool *valid_symbols\n) {\n  // ...\n}\n","\nif (valid_symbols[INDENT] || valid_symbols[DEDENT]) {\nNEWPARAGRAPH\n  // ... logic that is common to both `INDENT` and `DEDENT`\nNEWPARAGRAPH\n  if (valid_symbols[INDENT]) {\nNEWPARAGRAPH\n    // ... logic that is specific to `INDENT`\nNEWPARAGRAPH\n    lexer->result_symbol = INDENT;\n    return true;\n  }\n}\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/4-external-scanners.md","header":"External Scanner Helpers","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/4-external-scanners.md","header":"Allocator","text_blocks":["NEWPARAGRAPH\nInstead of using libc's `malloc`, `calloc`, `realloc`, and `free`, you should use the versions prefixed with `ts_` from `tree_sitter/alloc.h`.\nThese macros can allow a potential consumer to override the default allocator with their own implementation, but by default\nwill use the libc functions.\nNEWPARAGRAPH\nAs a consumer of the tree-sitter core library as well as any parser libraries that might use allocations, you can enable\noverriding the default allocator and have it use the same one as the library allocator, of which you can set with `ts_set_allocator`.\nTo enable this overriding in scanners, you must compile them with the `TREE_SITTER_REUSE_ALLOCATOR` macro defined, and tree-sitter\nthe library must be linked into your final app dynamically, since it needs to resolve the internal functions at runtime.\nIf you are compiling an executable binary that uses the core library, but want to load parsers dynamically at runtime, then\nyou will have to use a special linker flag on Unix. For non-Darwin systems, that would be `--dynamic-list` and for Darwin\nsystems, that would be `-exported_symbols_list`. The CLI does exactly this, so you can use it as a reference (check out `cli/build.rs`).\nNEWPARAGRAPH\nFor example, assuming you wanted to allocate 100 bytes for your scanner, you'd do so like the following example:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n#include \"tree_sitter/parser.h\"\n#include \"tree_sitter/alloc.h\"\nNEWPARAGRAPH\n// ...\nNEWPARAGRAPH\nvoid* tree_sitter_my_language_external_scanner_create() {\n  return ts_calloc(100, 1); // or ts_malloc(100)\n}\nNEWPARAGRAPH\n// ...\nNEWPARAGRAPH\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/4-external-scanners.md","header":"Arrays","text_blocks":["NEWPARAGRAPH\nIf you need to use array-like types in your scanner, such as tracking a stack of indentations or tags, you should use the\narray macros from `tree_sitter/array.h`.\nNEWPARAGRAPH\nThere are quite a few of them provided for you, but here's how you could get started tracking some . Check out the header\nitself for more detailed documentation.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\nDo not use any of the array functions or macros that are prefixed with an underscore and have comments saying\nthat it is not what you are looking for. These are internal functions used as helpers by other macros that are public.\nThey are not meant to be used directly, nor are they what you want.\n","\n#include \"tree_sitter/parser.h\"\n#include \"tree_sitter/array.h\"\nNEWPARAGRAPH\nenum TokenType {\n  INDENT,\n  DEDENT,\n  NEWLINE,\n  STRING,\n}\nNEWPARAGRAPH\n// Create the array in your create function\nNEWPARAGRAPH\nvoid* tree_sitter_my_language_external_scanner_create() {\n  return ts_calloc(1, sizeof(Array(int)));\nNEWPARAGRAPH\n  // or if you want to zero out the memory yourself\nNEWPARAGRAPH\n  Array(int) *stack = ts_malloc(sizeof(Array(int)));\n  array_init(&stack);\n  return stack;\n}\nNEWPARAGRAPH\nbool tree_sitter_my_language_external_scanner_scan(\n  void *payload,\n  TSLexer *lexer,\n  const bool *valid_symbols\n) {\n  Array(int) *stack = payload;\n  if (valid_symbols[INDENT]) {\n    array_push(stack, lexer->get_column(lexer));\n    lexer->result_symbol = INDENT;\n    return true;\n  }\n  if (valid_symbols[DEDENT]) {\n    array_pop(stack); // this returns the popped element by value, but we don't need it\n    lexer->result_symbol = DEDENT;\n    return true;\n  }\nNEWPARAGRAPH\n  // we can also use an array on the stack to keep track of a string\nNEWPARAGRAPH\n  Array(char) next_string = array_new();\nNEWPARAGRAPH\n  if (valid_symbols[STRING] && lexer->lookahead == '\"') {\n    lexer->advance(lexer, false);\n    while (lexer->lookahead != '\"' && lexer->lookahead != '\\n' && !lexer->eof(lexer)) {\n      array_push(&next_string, lexer->lookahead);\n      lexer->advance(lexer, false);\n    }\nNEWPARAGRAPH\n    // assume we have some arbitrary constraint of not having more than 100 characters in a string\n    if (lexer->lookahead == '\"' && next_string.size <= 100) {\n      lexer->advance(lexer, false);\n      lexer->result_symbol = STRING;\n      return true;\n    }\n  }\nNEWPARAGRAPH\n  return false;\n}\nNEWPARAGRAPH\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/4-external-scanners.md","header":"Other External Scanner Details","text_blocks":["NEWPARAGRAPH\nExternal scanners have priority over Tree-sitter's normal lexing process. When a token listed in the externals array is valid\nat a given position, the external scanner is called first. This makes external scanners a powerful way to override Tree-sitter's\ndefault lexing behavior, especially for cases that can't be handled with regular lexical rules, parsing, or dynamic precedence.\nNEWPARAGRAPH\nDuring error recovery, Tree-sitter's first step is to call the external scanner's scan function with all tokens marked as\nvalid. Your scanner should detect and handle this case appropriately. One simple approach is to add an unused \"sentinel\"\ntoken at the end of your externals array:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nYou can then check if this sentinel token is marked valid to determine if Tree-sitter is in error recovery mode.\nNEWPARAGRAPH\nIf you would rather not handle the error recovery case explicitly, the easiest way to \"opt-out\" and let tree-sitter's internal\nlexer handle it is to return `false` from your scan function when `valid_symbols` contains the error sentinel.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nWhen you include literal keywords in the externals array, for example:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n_those_ keywords will\nbe tokenized by the external scanner whenever they appear in the grammar.\nNEWPARAGRAPH\nThis is equivalent to declaring named tokens and aliasing them:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThe tokenization process for external keywords works in two stages:\nNEWPARAGRAPH\n1. The external scanner attempts to recognize the token first\n2. If the scanner returns true and sets a token, that token is used\n3. If the scanner returns false, Tree-sitter falls back to its internal lexer\nNEWPARAGRAPH\nHowever, when you use rule references (like `$.if_keyword`) in the externals array without defining the corresponding rules\nin the grammar, Tree-sitter cannot fall back to its internal lexer. In this case, the external scanner is solely responsible\nfor recognizing these tokens.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n[ejs]: https://ejs.co\n[enum]: https://en.wikipedia.org/wiki/Enumerated_type"],"code_blocks":["\n{\n  name: \"my_language\",\nNEWPARAGRAPH\n  externals: $ => [$.token1, $.token2, $.error_sentinel]\nNEWPARAGRAPH\n  // ...\n}\n","\nbool tree_sitter_my_language_external_scanner_scan(\n  void *payload,\n  TSLexer *lexer,\n  const bool *valid_symbols\n) {\n  if (valid_symbols[ERROR_SENTINEL]) {\n    return false;\n  }\n  // ...\n}\n","\nexternals: $ => ['if', 'then', 'else']\n","\n{\n  name: \"my_language\",\nNEWPARAGRAPH\n  externals: $ => [$.if_keyword, $.then_keyword, $.else_keyword],\nNEWPARAGRAPH\n  rules: {\nNEWPARAGRAPH\n    // then using it in a rule like so:\n    if_statement: $ => seq(alias($.if_keyword, 'if'), ...),\nNEWPARAGRAPH\n    // ...\n  }\n}\n","\n- External scanners can easily create infinite loops\nNEWPARAGRAPH\n- Be extremely careful when emitting zero-width tokens\nNEWPARAGRAPH\n- Always use the `eof` function when looping through characters\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/4-external-scanners.md","header":"C","text_blocks":["[heredoc]: https://en.wikipedia.org/wiki/Here_document\n[indent-tokens]: https://en.wikipedia.org/wiki/Off-side_rule\n[multi-language-section]: ../using-parsers/3-advanced-parsing.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/4-external-scanners.md","header":"multi-language-documents","text_blocks":["[percent-string]: https://docs.ruby-lang.org/en/2.5.0/doc/syntax/literals_rdoc.html"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/4-external-scanners.md","header":"label-Percent+Strings","text_blocks":[],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"Writing the Grammar","text_blocks":["NEWPARAGRAPH\nWriting a grammar requires creativity. There are an infinite number of CFGs (context-free grammars) that can be used to describe\nany given language. To produce a good Tree-sitter parser, you need to create a grammar with two important properties:\nNEWPARAGRAPH\n1. **An intuitive structure** — Tree-sitter's output is a [concrete syntax tree][cst]; each node in the tree corresponds\ndirectly to a [terminal or non-terminal symbol][non-terminal] in the grammar. So to produce an easy-to-analyze tree, there\nshould be a direct correspondence between the symbols in your grammar and the recognizable constructs in the language.\nThis might seem obvious, but it is very different from the way that context-free grammars are often written in contexts\nlike [language specifications][language-spec] or [Yacc][yacc]/[Bison][bison] parsers.\nNEWPARAGRAPH\n2. **A close adherence to LR(1)** — Tree-sitter is based on the [GLR parsing][glr-parsing] algorithm. This means that while\nit can handle any context-free grammar, it works most efficiently with a class of context-free grammars called [LR(1) Grammars][lr-grammars].\nIn this respect, Tree-sitter's grammars are similar to (but less restrictive than) [Yacc][yacc] and [Bison][bison] grammars,\nbut _different_ from [ANTLR grammars][antlr], [Parsing Expression Grammars][peg], or the [ambiguous grammars][ambiguous-grammar]\ncommonly used in language specifications.\nNEWPARAGRAPH\nIt's unlikely that you'll be able to satisfy these two properties just by translating an existing context-free grammar directly\ninto Tree-sitter's grammar format. There are a few kinds of adjustments that are often required.\nThe following sections will explain these adjustments in more depth.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"The First Few Rules","text_blocks":["NEWPARAGRAPH\nIt's usually a good idea to find a formal specification for the language you're trying to parse. This specification will\nmost likely contain a context-free grammar. As you read through the rules of this CFG, you will probably discover a complex\nand cyclic graph of relationships. It might be unclear how you should navigate this graph as you define your grammar.\nNEWPARAGRAPH\nAlthough languages have very different constructs, their constructs can often be categorized in to similar groups like\n_Declarations_, _Definitions_, _Statements_, _Expressions_, _Types_ and _Patterns_. In writing your grammar, a good first\nstep is to create just enough structure to include all of these basic _groups_ of symbols. For a language like Go,\nyou might start with something like this:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nOne important fact to know up front is that the start rule for the grammar is the first property in the `rules` object.\nIn the example above, that would correspond to `source_file`, but it can be named anything.\nNEWPARAGRAPH\nSome details of this grammar will be explained in more depth later on, but if you focus on the `TODO` comments, you can\nsee that the overall strategy is _breadth-first_. Notably, this initial skeleton does not need to directly match an exact\nsubset of the context-free grammar in the language specification. It just needs to touch on the major groupings of rules\nin as simple and obvious a way as possible.\nNEWPARAGRAPH\nWith this structure in place, you can now freely decide what part of the grammar to flesh out next. For example, you might\ndecide to start with _types_. One-by-one, you could define the rules for writing basic types and composing them into more\ncomplex types:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nAfter developing the _type_ sublanguage a bit further, you might decide to switch to working on _statements_ or _expressions_\ninstead. It's often useful to check your progress by trying to parse some real code using `tree-sitter parse`.\nNEWPARAGRAPH\n**And remember to add tests for each rule in your `test/corpus` folder!**\nNEWPARAGRAPH\n"],"code_blocks":["\n{\n  // ...\nNEWPARAGRAPH\n  rules: {\n    source_file: $ => repeat($._definition),\nNEWPARAGRAPH\n    _definition: $ => choice(\n      $.function_definition\n      // TODO: other kinds of definitions\n    ),\nNEWPARAGRAPH\n    function_definition: $ => seq(\n      'func',\n      $.identifier,\n      $.parameter_list,\n      $._type,\n      $.block\n    ),\nNEWPARAGRAPH\n    parameter_list: $ => seq(\n      '(',\n       // TODO: parameters\n      ')'\n    ),\nNEWPARAGRAPH\n    _type: $ => choice(\n      'bool'\n      // TODO: other kinds of types\n    ),\nNEWPARAGRAPH\n    block: $ => seq(\n      '{',\n      repeat($._statement),\n      '}'\n    ),\nNEWPARAGRAPH\n    _statement: $ => choice(\n      $.return_statement\n      // TODO: other kinds of statements\n    ),\nNEWPARAGRAPH\n    return_statement: $ => seq(\n      'return',\n      $._expression,\n      ';'\n    ),\nNEWPARAGRAPH\n    _expression: $ => choice(\n      $.identifier,\n      $.number\n      // TODO: other kinds of expressions\n    ),\nNEWPARAGRAPH\n    identifier: $ => /[a-z]+/,\nNEWPARAGRAPH\n    number: $ => /\\d+/\n  }\n}\n","\n{\n  // ...\nNEWPARAGRAPH\n  _type: $ => choice(\n    $.primitive_type,\n    $.array_type,\n    $.pointer_type\n  ),\nNEWPARAGRAPH\n  primitive_type: $ => choice(\n    'bool',\n    'int'\n  ),\nNEWPARAGRAPH\n  array_type: $ => seq(\n    '[',\n    ']',\n    $._type\n  ),\nNEWPARAGRAPH\n  pointer_type: $ => seq(\n    '*',\n    $._type\n  )\n}\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"Structuring Rules Well","text_blocks":["NEWPARAGRAPH\nImagine that you were just starting work on the [Tree-sitter JavaScript parser][tree-sitter-javascript]. Naively, you might\ntry to directly mirror the structure of the [ECMAScript Language Spec][ecmascript-spec]. To illustrate the problem with this\napproach, consider the following line of code:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nAccording to the specification, this line is a `ReturnStatement`, the fragment `x + y` is an `AdditiveExpression`,\nand `x` and `y` are both `IdentifierReferences`. The relationship between these constructs is captured by a complex series\nof production rules:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThe language spec encodes the twenty different precedence levels of JavaScript expressions using twenty levels of indirection\nbetween `IdentifierReference` and `Expression`. If we were to create a concrete syntax tree representing this statement\naccording to the language spec, it would have twenty levels of nesting, and it would contain nodes with names like `BitwiseXORExpression`,\nwhich are unrelated to the actual code.\nNEWPARAGRAPH\n"],"code_blocks":["\nreturn x + y;\n","\nReturnStatement          ->  'return' Expression\nExpression               ->  AssignmentExpression\nAssignmentExpression     ->  ConditionalExpression\nConditionalExpression    ->  LogicalORExpression\nLogicalORExpression      ->  LogicalANDExpression\nLogicalANDExpression     ->  BitwiseORExpression\nBitwiseORExpression      ->  BitwiseXORExpression\nBitwiseXORExpression     ->  BitwiseANDExpression\nBitwiseANDExpression     ->  EqualityExpression\nEqualityExpression       ->  RelationalExpression\nRelationalExpression     ->  ShiftExpression\nShiftExpression          ->  AdditiveExpression\nAdditiveExpression       ->  MultiplicativeExpression\nMultiplicativeExpression ->  ExponentiationExpression\nExponentiationExpression ->  UnaryExpression\nUnaryExpression          ->  UpdateExpression\nUpdateExpression         ->  LeftHandSideExpression\nLeftHandSideExpression   ->  NewExpression\nNewExpression            ->  MemberExpression\nMemberExpression         ->  PrimaryExpression\nPrimaryExpression        ->  IdentifierReference\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"Standard Rule Names","text_blocks":["NEWPARAGRAPH\nTree-sitter places no restrictions on how to name the rules of your grammar. It can be helpful, however, to follow certain conventions\nused by many other established grammars in the ecosystem. Some of these well-established patterns are listed below:\nNEWPARAGRAPH\n- `source_file`: Represents an entire source file, this rule is commonly used as the root node for a grammar,\n- `expression`/`statement`: Used to represent statements and expressions for a given language. Commonly defined as a choice between several\nmore specific sub-expression/sub-statement rules.\n- `block`: Used as the parent node for block scopes, with its children representing the block's contents.\n- `type`: Represents the types of a language such as `int`, `char`, and `void`.\n- `identifier`: Used for constructs like variable names, function arguments, and object fields; this rule is commonly used as the `word`\ntoken in grammars.\n- `string`: Used to represent `\"string literals\"`.\n- `comment`: Used to represent comments, this rule is commonly used as an `extra`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"Using Precedence","text_blocks":["NEWPARAGRAPH\nTo produce a readable syntax tree, we'd like to model JavaScript expressions using a much flatter structure like this:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nOf course, this flat structure is highly ambiguous. If we try to generate a parser, Tree-sitter gives us an error message:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n","NEWPARAGRAPH\nFor an expression like `-a * b`, it's not clear whether the `-` operator applies to the `a * b` or just to the `a`. This\nis where the `prec` function [described in the previous page][grammar dsl] comes into play. By wrapping a rule with `prec`,\nwe can indicate that certain sequence of symbols should _bind to each other more tightly_ than others. For example, the\n`'-', $._expression` sequence in `unary_expression` should bind more tightly than the `$._expression, '+', $._expression`\nsequence in `binary_expression`:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\n{\n  // ...\nNEWPARAGRAPH\n  _expression: $ => choice(\n    $.identifier,\n    $.unary_expression,\n    $.binary_expression,\n    // ...\n  ),\nNEWPARAGRAPH\n  unary_expression: $ => choice(\n    seq('-', $._expression),\n    seq('!', $._expression),\n    // ...\n  ),\nNEWPARAGRAPH\n  binary_expression: $ => choice(\n    seq($._expression, '*', $._expression),\n    seq($._expression, '+', $._expression),\n    // ...\n  ),\n}\n","\nError: Unresolved conflict for symbol sequence:\nNEWPARAGRAPH\n  '-'  _expression  •  '*'  …\nNEWPARAGRAPH\nPossible interpretations:\nNEWPARAGRAPH\n  1:  '-'  (binary_expression  _expression  •  '*'  _expression)\n  2:  (unary_expression  '-'  _expression)  •  '*'  …\nNEWPARAGRAPH\nPossible resolutions:\nNEWPARAGRAPH\n  1:  Specify a higher precedence in `binary_expression` than in the other rules.\n  2:  Specify a higher precedence in `unary_expression` than in the other rules.\n  3:  Specify a left or right associativity in `unary_expression`\n  4:  Add a conflict for these rules: `binary_expression` `unary_expression`\n","\nThe • character in the error message indicates where exactly during\nparsing the conflict occurs, or in other words, where the parser is encountering\nambiguity.\n","\n{\n  // ...\nNEWPARAGRAPH\n  unary_expression: $ =>\n    prec(\n      2,\n      choice(\n        seq(\"-\", $._expression),\n        seq(\"!\", $._expression),\n        // ...\n      ),\n    );\n}\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"Using Associativity","text_blocks":["NEWPARAGRAPH\nApplying a higher precedence in `unary_expression` fixes that conflict, but there is still another conflict:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nFor an expression like `a * b * c`, it's not clear whether we mean `a * (b * c)` or `(a * b) * c`.\nThis is where `prec.left` and `prec.right` come into use. We want to select the second interpretation, so we use `prec.left`.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\nError: Unresolved conflict for symbol sequence:\nNEWPARAGRAPH\n  _expression  '*'  _expression  •  '*'  …\nNEWPARAGRAPH\nPossible interpretations:\nNEWPARAGRAPH\n  1:  _expression  '*'  (binary_expression  _expression  •  '*'  _expression)\n  2:  (binary_expression  _expression  '*'  _expression)  •  '*'  …\nNEWPARAGRAPH\nPossible resolutions:\nNEWPARAGRAPH\n  1:  Specify a left or right associativity in `binary_expression`\n  2:  Add a conflict for these rules: `binary_expression`\n","\n{\n  // ...\nNEWPARAGRAPH\n  binary_expression: $ => choice(\n    prec.left(2, seq($._expression, '*', $._expression)),\n    prec.left(1, seq($._expression, '+', $._expression)),\n    // ...\n  ),\n}\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"Using Conflicts","text_blocks":["NEWPARAGRAPH\nSometimes, conflicts are actually desirable. In our JavaScript grammar, expressions and patterns can create intentional ambiguity.\nA construct like `[x, y]` could be legitimately parsed as both an array literal (like in `let a = [x, y]`) or as a destructuring\npattern (like in `let [x, y] = arr`).\nNEWPARAGRAPH\n","NEWPARAGRAPH\nIn such cases, we want the parser to explore both possibilities by explicitly declaring this ambiguity:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\nmodule.exports = grammar({\n  name: \"javascript\",\nNEWPARAGRAPH\n  rules: {\n    expression: $ => choice(\n      $.identifier,\n      $.array,\n      $.pattern,\n    ),\nNEWPARAGRAPH\n    array: $ => seq(\n      \"[\",\n      optional(seq(\n        $.expression, repeat(seq(\",\", $.expression))\n      )),\n      \"]\"\n    ),\nNEWPARAGRAPH\n    array_pattern: $ => seq(\n      \"[\",\n      optional(seq(\n        $.pattern, repeat(seq(\",\", $.pattern))\n      )),\n      \"]\"\n    ),\nNEWPARAGRAPH\n    pattern: $ => choice(\n      $.identifier,\n      $.array_pattern,\n    ),\n  },\n})\n","\n{\n  name: \"javascript\",\nNEWPARAGRAPH\n  conflicts: $ => [\n    [$.array, $.array_pattern],\n  ],\nNEWPARAGRAPH\n  rules: {\n    // ...\n  },\n}\n","\nThe example is a bit contrived for the purpose of illustrating the usage of conflicts. The actual JavaScript grammar isn't\nstructured like that, but this conflict is actually present in the\n[Tree-sitter JavaScript grammar](https://github.com/tree-sitter/tree-sitter-javascript/blob/108b2d4d17a04356a340aea809e4dd5b801eb40d/grammar.js#L100).\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"Hiding Rules","text_blocks":["NEWPARAGRAPH\nYou may have noticed in the above examples that some grammar rule name like `_expression` and `_type` began with an underscore.\nStarting a rule's name with an underscore causes the rule to be _hidden_ in the syntax tree. This is useful for rules like\n`_expression` in the grammars above, which always just wrap a single child node. If these nodes were not hidden, they would\nadd substantial depth and noise to the syntax tree without making it any easier to understand.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"Using Fields","text_blocks":["NEWPARAGRAPH\nOften, it's easier to analyze a syntax node if you can refer to its children by _name_ instead of by their position in an\nordered list. Tree-sitter grammars support this using the `field` function. This function allows you to assign unique names\nto some or all of a node's children:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nAdding fields like this allows you to retrieve nodes using the [field APIs][field-names-section].\nNEWPARAGRAPH\n"],"code_blocks":["\nfunction_definition: $ =>\n  seq(\n    \"func\",\n    field(\"name\", $.identifier),\n    field(\"parameters\", $.parameter_list),\n    field(\"return_type\", $._type),\n    field(\"body\", $.block),\n  );\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"Lexical Analysis","text_blocks":["NEWPARAGRAPH\nTree-sitter's parsing process is divided into two phases: parsing (which is described above) and [lexing][lexing] — the\nprocess of grouping individual characters into the language's fundamental _tokens_. There are a few important things to\nknow about how Tree-sitter's lexing works.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"Conflicting Tokens","text_blocks":["NEWPARAGRAPH\nGrammars often contain multiple tokens that can match the same characters. For example, a grammar might contain the tokens\n(`\"if\"` and `/[a-z]+/`). Tree-sitter differentiates between these conflicting tokens in a few ways.\nNEWPARAGRAPH\n1. **Context-aware Lexing** — Tree-sitter performs lexing on-demand, during the parsing process. At any given position\nin a source document, the lexer only tries to recognize tokens that are _valid_ at that position in the document.\nNEWPARAGRAPH\n2. **Lexical Precedence** — When the precedence functions described [in the previous page][grammar dsl] are used _within_\nthe `token` function, the given explicit precedence values serve as instructions to the lexer. If there are two valid tokens\nthat match the characters at a given position in the document, Tree-sitter will select the one with the higher precedence.\nNEWPARAGRAPH\n3. **Match Length** — If multiple valid tokens with the same precedence match the characters at a given position in a document,\nTree-sitter will select the token that matches the [longest sequence of characters][longest-match].\nNEWPARAGRAPH\n4. **Match Specificity** — If there are two valid tokens with the same precedence, and they both match the same number\nof characters, Tree-sitter will prefer a token that is specified in the grammar as a `String` over a token specified as\na `RegExp`.\nNEWPARAGRAPH\n5. **Rule Order** — If none of the above criteria can be used to select one token over another, Tree-sitter will prefer\nthe token that appears earlier in the grammar.\nNEWPARAGRAPH\nIf there is an external scanner it may have [an additional impact][external scanner] over regular tokens\ndefined in the grammar.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"Lexical Precedence vs. Parse Precedence","text_blocks":["NEWPARAGRAPH\nOne common mistake involves not distinguishing _lexical precedence_ from _parse precedence_. Parse precedence determines\nwhich rule is chosen to interpret a given sequence of tokens. _Lexical precedence_ determines which token is chosen to interpret\nat a given position of text, and it is a lower-level operation that is done first. The above list fully captures Tree-sitter's\nlexical precedence rules, and you will probably refer back to this section of the documentation more often than any other.\nMost of the time when you really get stuck, you're dealing with a lexical precedence problem. Pay particular attention to\nthe difference in meaning between using `prec` inside the `token` function versus outside it. The _lexical precedence_ syntax,\nas mentioned in the previous page, is `token(prec(N, ...))`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"Keywords","text_blocks":["NEWPARAGRAPH\nMany languages have a set of _keyword_ tokens (e.g. `if`, `for`, `return`), as well as a more general token (e.g. `identifier`)\nthat matches any word, including many of the keyword strings. For example, JavaScript has a keyword `instanceof`, which is\nused as a binary operator, like this:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThe following, however, is not valid JavaScript:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nA keyword like `instanceof` cannot be followed immediately by another letter, because then it would be tokenized as an `identifier`,\n**even though an identifier is not valid at that position**. Because Tree-sitter uses context-aware lexing, as described\n[above]("],"code_blocks":["\nif (a instanceof Something) b();\n","\nif (a instanceofSomething) b();\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"conflicting-tokens), it would not normally impose this restriction. By default, Tree-sitter would recognize `instanceofSomething`","text_blocks":["as two separate tokens: the `instanceof` keyword followed by an `identifier`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"Keyword Extraction","text_blocks":["NEWPARAGRAPH\nFortunately, Tree-sitter has a feature that allows you to fix this, so that you can match the behavior of other standard\nparsers: the `word` token. If you specify a `word` token in your grammar, Tree-sitter will find the set of _keyword_ tokens\nthat match strings also matched by the `word` token. Then, during lexing, instead of matching each of these keywords individually,\nTree-sitter will match the keywords via a two-step process where it _first_ matches the `word` token.\nNEWPARAGRAPH\nFor example, suppose we added `identifier` as the `word` token in our JavaScript grammar:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nTree-sitter would identify `typeof` and `instanceof` as keywords. Then, when parsing the invalid code above, rather than\nscanning for the `instanceof` token individually, it would scan for an `identifier` first, and find `instanceofSomething`.\nIt would then correctly recognize the code as invalid.\nNEWPARAGRAPH\nAside from improving error detection, keyword extraction also has performance benefits. It allows Tree-sitter to generate\na smaller, simpler lexing function, which means that **the parser will compile much more quickly**.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n[ambiguous-grammar]: https://en.wikipedia.org/wiki/Ambiguous_grammar\n[antlr]: https://www.antlr.org\n[bison]: https://en.wikipedia.org/wiki/GNU_bison\n[cst]: https://en.wikipedia.org/wiki/Parse_tree\n[ecmascript-spec]: https://262.ecma-international.org/6.0/\n[external scanner]: ./4-external-scanners.md"],"code_blocks":["\ngrammar({\n  name: \"javascript\",\nNEWPARAGRAPH\n  word: $ => $.identifier,\nNEWPARAGRAPH\n  rules: {\n    _expression: $ =>\n      choice(\n        $.identifier,\n        $.unary_expression,\n        $.binary_expression,\n        // ...\n      ),\nNEWPARAGRAPH\n    binary_expression: $ =>\n      choice(\n        prec.left(1, seq($._expression, \"instanceof\", $._expression)),\n        // ...\n      ),\nNEWPARAGRAPH\n    unary_expression: $ =>\n      choice(\n        prec.left(2, seq(\"typeof\", $._expression)),\n        // ...\n      ),\nNEWPARAGRAPH\n    identifier: $ => /[a-z_]+/,\n  },\n});\n","\nThe word token must be a unique token that is not reused by another rule. If you want to have a word token used in a\nrule that's called something else, you should just alias the word token instead, like how the Rust grammar does it\n<a href=\"https://github.com/tree-sitter/tree-sitter-rust/blob/1f63b33efee17e833e0ea29266dd3d713e27e321/grammar.js#L1605\">here</a>\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"other-external-scanner-details","text_blocks":["[glr-parsing]: https://en.wikipedia.org/wiki/GLR_parser\n[grammar dsl]: ./2-the-grammar-dsl.md\n[language-spec]: https://en.wikipedia.org/wiki/Programming_language_specification\n[lexing]: https://en.wikipedia.org/wiki/Lexical_analysis\n[longest-match]: https://en.wikipedia.org/wiki/Maximal_munch\n[lr-grammars]: https://en.wikipedia.org/wiki/LR_parser\n[field-names-section]: ../using-parsers/2-basic-parsing.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/3-writing-the-grammar.md","header":"node-field-names","text_blocks":["[non-terminal]: https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols\n[peg]: https://en.wikipedia.org/wiki/Parsing_expression_grammar\n[tree-sitter-javascript]: https://github.com/tree-sitter/tree-sitter-javascript\n[yacc]: https://en.wikipedia.org/wiki/Yacc"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/5-writing-tests.md","header":"Writing Tests","text_blocks":["NEWPARAGRAPH\nFor each rule that you add to the grammar, you should first create a *test* that describes how the syntax trees should look\nwhen parsing that rule. These tests are written using specially-formatted text files in the `test/corpus/` directory within\nyour parser's root folder.\nNEWPARAGRAPH\nFor example, you might have a file called `test/corpus/statements.txt` that contains a series of entries like this:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n* The **name** of each test is written between two lines containing only `=` (equal sign) characters.\nNEWPARAGRAPH\n* Then the **input source code** is written, followed by a line containing three or more `-` (dash) characters.\nNEWPARAGRAPH\n* Then, the **expected output syntax tree** is written as an [S-expression][s-exp]. The exact placement of whitespace in\nthe S-expression doesn't matter, but ideally the syntax tree should be legible.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n  The expected output section can also *optionally* show the [*field names*][node-field-names] associated with each child\n  node. To include field names in your tests, you write a node's field name followed by a colon, before the node itself in\n  the S-expression:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n* If your language's syntax conflicts with the `===` and `---` test separators, you can optionally add an arbitrary identical\nsuffix (in the below example, `|||`) to disambiguate them:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThese tests are important. They serve as the parser's API documentation, and they can be run every time you change the grammar\nto verify that everything still parses correctly.\nNEWPARAGRAPH\nBy default, the `tree-sitter test` command runs all the tests in your `test/corpus/` folder. To run a particular test, you\ncan use the `-i` flag:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThe recommendation is to be comprehensive in adding tests. If it's a visible node, add it to a test file in your `test/corpus`\ndirectory. It's typically a good idea to test all the permutations of each language construct. This increases test coverage,\nbut doubly acquaints readers with a way to examine expected outputs and understand the \"edges\" of a language.\nNEWPARAGRAPH\n"],"code_blocks":["\n==================\nReturn statements\n==================\nNEWPARAGRAPH\nfunc x() int {\n  return 1;\n}\nNEWPARAGRAPH\n---\nNEWPARAGRAPH\n(source_file\n  (function_definition\n    (identifier)\n    (parameter_list)\n    (primitive_type)\n    (block\n      (return_statement (number)))))\n","\nThe S-expression does not show syntax nodes like `func`, `(` and `;`, which are expressed as strings and regexes in the grammar.\nIt only shows the *named* nodes, as described in [this section][named-vs-anonymous-nodes] of the page on parser usage.\n","\n(source_file\n  (function_definition\n    name: (identifier)\n    parameters: (parameter_list)\n    result: (primitive_type)\n    body: (block\n      (return_statement (number)))))\n","\n==================|||\nBasic module\n==================|||\nNEWPARAGRAPH\n---- MODULE Test ----\nincrement(n) == n + 1\n====\nNEWPARAGRAPH\n---|||\nNEWPARAGRAPH\n(source_file\n  (module (identifier)\n    (operator (identifier)\n      (parameter_list (identifier))\n      (plus (identifier_ref) (number)))))\n","\ntree-sitter test -i 'Return statements'\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/5-writing-tests.md","header":"Attributes","text_blocks":["NEWPARAGRAPH\nTests can be annotated with a few `attributes`. Attributes must be put in the header, below the test name, and start with\na `:`. A couple of attributes also take in a parameter, which require the use of parenthesis.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThe following attributes are available:\nNEWPARAGRAPH\n* `:skip` — This attribute will skip the test when running `tree-sitter test`.\n  This is useful when you want to temporarily disable running a test without deleting it.\n* `:error` — This attribute will assert that the parse tree contains an error. It's useful to just validate that a certain\ninput is invalid without displaying the whole parse tree, as such you should omit the parse tree below the `---` line.\n* `:fail-fast` — This attribute will stop the testing additional tests if the test marked with this attribute fails.\n* `:language(LANG)` — This attribute will run the tests using the parser for the specified language. This is useful for\nmulti-parser repos, such as XML and DTD, or Typescript and TSX. The default parser used will always be the first entry in\nthe `grammars` field in the `tree-sitter.json` config file, so having a way to pick a second or even third parser is useful.\n* `:platform(PLATFORM)` — This attribute specifies the platform on which the test should run. It is useful to test platform-specific\nbehavior (e.g. Windows newlines are different from Unix). This attribute must match up with Rust's [`std::env::consts::OS`][constants].\nNEWPARAGRAPH\nExamples using attributes:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\nIf you'd like to supply in multiple parameters, e.g. to run tests on multiple platforms or to test multiple languages,\nyou can repeat the attribute on a new line.\n","\n=========================\nTest that will be skipped\n:skip\n=========================\nNEWPARAGRAPH\nint main() {}\nNEWPARAGRAPH\n-------------------------\nNEWPARAGRAPH\n====================================\nTest that will run on Linux or macOS\nNEWPARAGRAPH\n:platform(linux)\n:platform(macos)\n====================================\nNEWPARAGRAPH\nint main() {}\nNEWPARAGRAPH\n------------------------------------\nNEWPARAGRAPH\n========================================================================\nTest that expects an error, and will fail fast if there's no parse error\n:fail-fast\n:error\n========================================================================\nNEWPARAGRAPH\nint main ( {}\nNEWPARAGRAPH\n------------------------------------------------------------------------\nNEWPARAGRAPH\n=================================================\nTest that will parse with both Typescript and TSX\n:language(typescript)\n:language(tsx)\n=================================================\nNEWPARAGRAPH\nconsole.log('Hello, world!');\nNEWPARAGRAPH\n-------------------------------------------------\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/5-writing-tests.md","header":"Automatic Compilation","text_blocks":["NEWPARAGRAPH\nYou might notice that the first time you run `tree-sitter test` after regenerating your parser, it takes some extra time.\nThis is because Tree-sitter automatically compiles your C code into a dynamically-loadable library. It recompiles your parser\nas-needed whenever you update it by re-running `tree-sitter generate`, or whenever the [external scanner][external-scanners]\nfile is changed.\nNEWPARAGRAPH\n[constants]: https://doc.rust-lang.org/std/env/consts/constant.OS.html\n[external-scanners]: ./4-external-scanners.md\n[node-field-names]: ../using-parsers/2-basic-parsing.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/5-writing-tests.md","header":"node-field-names","text_blocks":["[s-exp]: https://en.wikipedia.org/wiki/S-expression\n[named-vs-anonymous-nodes]: ../using-parsers/2-basic-parsing.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/5-writing-tests.md","header":"named-vs-anonymous-nodes","text_blocks":[],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/index.md","header":"Creating parsers","text_blocks":["NEWPARAGRAPH\nDeveloping Tree-sitter grammars can have a difficult learning curve, but once you get the hang of it, it can be fun and even\nzen-like. This document will help you to get started and to develop a useful mental model."],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/6-publishing.md","header":"Publishing your grammar","text_blocks":["NEWPARAGRAPH\nOnce you feel that your parser is in a stable working state for consumers to use, you can publish it to various registries.\nIt's strongly recommended to publish grammars to GitHub, [crates.io][crates.io] (Rust), [npm][npm] (JavaScript), and [PyPI][pypi]\n(Python) to make it easier for others to find and use your grammar.\nNEWPARAGRAPH\nIf your grammar is hosted on GitHub, you can make use of our [reusable workflows][workflows] to handle the publishing process\nfor you. This action will automatically handle regenerating and publishing your grammar in CI, so long as you have the required\ntokens setup for the various registries. For an example of this workflow in action, see the [Python grammar's GitHub][python-gh]\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/6-publishing.md","header":"From start to finish","text_blocks":["NEWPARAGRAPH\nTo release a new grammar (or publish your first version), these are the steps you should follow:\nNEWPARAGRAPH\n1. Bump your version to the desired version with `tree-sitter version`. For example, if you're releasing version `1.0.0`\nof your grammar, you'd run `tree-sitter version 1.0.0`.\n2. Commit the changes with `git commit -am \"Release 1.0.0\" (or however you like)` (ensure that your working directory is\nclean).\n3. Tag the commit with `git tag -- v1.0.0`.\n4. Push the commit and tag with `git push --tags origin main` (assuming you're on the `main` branch, and `origin` is your\nremote).\n5. (optional) If you've set up the GitHub workflows for your grammar, the release will be automatically published to GitHub,\ncrates.io, npm, and PyPI.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/6-publishing.md","header":"Adhering to Semantic Versioning","text_blocks":["NEWPARAGRAPH\nWhen releasing new versions of your grammar, it's important to adhere to [Semantic Versioning][semver]. This ensures that\nconsumers can predictably update their dependencies and that their existing tree-sitter integrations (queries, tree traversal\ncode, node type checks) will continue to work as expected when upgrading.\nNEWPARAGRAPH\n1. Increment the major version when you make incompatible changes to the grammar's node types or structure\n2. Increment the minor version when you add new node types or patterns while maintaining backward compatibility\n3. Increment the patch version when you fix bugs without changing the grammar's structure\nNEWPARAGRAPH\nFor grammars in version 0.y.z (zero version), the usual semantic versioning rules are technically relaxed. However, if your\ngrammar already has users, it's recommended to treat version changes more conservatively:\nNEWPARAGRAPH\n- Treat patch version (`z`) changes as if they were minor version changes\n- Treat minor version (`y`) changes as if they were major version changes\nNEWPARAGRAPH\nThis helps maintain stability for existing users during the pre-1.0 phase. By following these versioning guidelines, you\nensure that downstream users can safely upgrade without their existing queries breaking.\nNEWPARAGRAPH\n[crates.io]: https://crates.io\n[npm]: https://www.npmjs.com\n[pypi]: https://pypi.org\n[python-gh]: https://github.com/tree-sitter/tree-sitter-python/blob/master/.github/workflows/publish.yml\n[semver]: https://semver.org/\n[workflows]: https://github.com/tree-sitter/workflows"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/1-getting-started.md","header":"Getting Started","text_blocks":["NEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/1-getting-started.md","header":"Dependencies","text_blocks":["NEWPARAGRAPH\nTo develop a Tree-sitter parser, there are two dependencies that you need to install:\nNEWPARAGRAPH\n- **A JavaScript runtime** — Tree-sitter grammars are written in JavaScript, and Tree-sitter uses a JavaScript runtime\n(the default being [Node.js][node.js]) to interpret JavaScript files. It requires this runtime command (default: `node`)\nto be in one of the directories in your [`PATH`][path-env].\nNEWPARAGRAPH\n- **A C Compiler** — Tree-sitter creates parsers that are written in C. To run and test these parsers with the\n`tree-sitter parse` or `tree-sitter test` commands, you must have a C/C++ compiler installed. Tree-sitter will try to look\nfor these compilers in the standard places for each platform.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/1-getting-started.md","header":"Installation","text_blocks":["NEWPARAGRAPH\nTo create a Tree-sitter parser, you need to use [the `tree-sitter` CLI][tree-sitter-cli]. You can install the CLI in a few\ndifferent ways:\nNEWPARAGRAPH\n- Build the `tree-sitter-cli` [Rust crate][crate] from source using [`cargo`][cargo], the Rust package manager. This works\non any platform. See [the contributing docs](../6-contributing.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/1-getting-started.md","header":"developing-tree-sitter) for more information.","text_blocks":["NEWPARAGRAPH\n- Install the `tree-sitter-cli` [Rust crate][crate] from [crates.io][crates.io] using [`cargo`][cargo]. You can do so by\nrunning the following command: `cargo install tree-sitter-cli --locked`\nNEWPARAGRAPH\n- Install the `tree-sitter-cli` [Node.js module][node-module] using [`npm`][npm], the Node package manager. This approach\nis fast, but it only works on certain platforms, because it relies on pre-built binaries.\nNEWPARAGRAPH\n- Download a binary for your platform from [the latest GitHub release][releases], and put it into a directory on your `PATH`.\nNEWPARAGRAPH\n"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/1-getting-started.md","header":"Project Setup","text_blocks":["NEWPARAGRAPH\nThe preferred convention is to name the parser repository \"tree-sitter-\" followed by the name of the language, in lowercase.\nNEWPARAGRAPH\n","NEWPARAGRAPH\n","NEWPARAGRAPH\n"],"code_blocks":["\nmkdir tree-sitter-${LOWER_PARSER_NAME}\ncd tree-sitter-${LOWER_PARSER_NAME}\n","\nThe `LOWER_` prefix here means the \"lowercase\" name of the language.\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/1-getting-started.md","header":"Init","text_blocks":["NEWPARAGRAPH\nOnce you've installed the `tree-sitter` CLI tool, you can start setting up your project, which will allow your parser to\nbe used from multiple languages.\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThe `init` command will create a bunch of files in the project.\nThere should be a file called `grammar.js` with the following contents:\nNEWPARAGRAPH\n","NEWPARAGRAPH\n","NEWPARAGRAPH\nTo learn more about this command, check the [reference page](../cli/init.md).\nNEWPARAGRAPH\n"],"code_blocks":["\n# This will prompt you for input\ntree-sitter init\n","\n/**\n * @file PARSER_DESCRIPTION\n * @author PARSER_AUTHOR_NAME PARSER_AUTHOR_EMAIL\n * @license PARSER_LICENSE\n */\nNEWPARAGRAPH\n/// <reference types=\"tree-sitter-cli/dsl\" />\n// @ts-check\nNEWPARAGRAPH\nmodule.exports = grammar({\n  name: 'LOWER_PARSER_NAME',\nNEWPARAGRAPH\n  rules: {\n    // TODO: add the actual grammar rules\n    source_file: $ => 'hello'\n  }\n});\n","\nThe placeholders shown above would be replaced with the corresponding data you provided in the `init` sub-command's\nprompts.\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/1-getting-started.md","header":"Generate","text_blocks":["NEWPARAGRAPH\nNext, run the following command:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis will generate the C code required to parse this trivial language.\nNEWPARAGRAPH\nYou can test this parser by creating a source file with the contents \"hello\" and parsing it:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nAlternatively, in Windows PowerShell:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nThis should print the following:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nYou now have a working parser.\nNEWPARAGRAPH\nFinally, look back at the [triple-slash][] and [`@ts-check`][ts-check] comments in `grammar.js`; these tell your editor\nto provide documentation and type information as you edit your grammar. For these to work, you must download Tree-sitter's\nTypeScript API from npm into a `node_modules` directory in your project:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nTo learn more about this command, check the [reference page](../cli/generate.md).\nNEWPARAGRAPH\n[cargo]: https://doc.rust-lang.org/cargo/getting-started/installation.html\n[crate]: https://crates.io/crates/tree-sitter-cli\n[crates.io]: https://crates.io/crates/tree-sitter-cli\n[node-module]: https://www.npmjs.com/package/tree-sitter-cli\n[node.js]: https://nodejs.org\n[npm]: https://docs.npmjs.com\n[path-env]: https://en.wikipedia.org/wiki/PATH_(variable)\n[releases]: https://github.com/tree-sitter/tree-sitter/releases/latest\n[tree-sitter-cli]: https://github.com/tree-sitter/tree-sitter/tree/master/cli\n[triple-slash]: https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html\n[ts-check]: https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html"],"code_blocks":["\ntree-sitter generate\n","\necho 'hello' > example-file\ntree-sitter parse example-file\n","\n\"hello\" | Out-File example-file -Encoding utf8\ntree-sitter parse example-file\n","\n(source_file [0, 0] - [1, 0])\n","\nnpm install # or your package manager of choice\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/2-the-grammar-dsl.md","header":"The Grammar DSL","text_blocks":["NEWPARAGRAPH\nThe following is a complete list of built-in functions you can use in your `grammar.js` to define rules. Use-cases for some\nof these functions will be explained in more detail in later sections.\nNEWPARAGRAPH\n- **Symbols (the `$` object)** — Every grammar rule is written as a JavaScript function that takes a parameter conventionally\ncalled `$`. The syntax `$.identifier` is how you refer to another grammar symbol within a rule. Names starting with `$.MISSING`\nor `$.UNEXPECTED` should be avoided as they have special meaning for the `tree-sitter test` command.\n- **String and Regex literals** — The terminal symbols in a grammar are described using JavaScript strings and regular\nexpressions. Of course during parsing, Tree-sitter does not actually use JavaScript's regex engine to evaluate these regexes;\nit generates its own regex-matching logic based on the Rust regex syntax as part of each parser. Regex literals are just\nused as a convenient way of writing regular expressions in your grammar. You can use Rust regular expressions in your grammar\nDSL through the `RustRegex` class. Simply pass your regex pattern as a string:\nNEWPARAGRAPH\n","NEWPARAGRAPH\nUnlike JavaScript's builtin `RegExp` class, which takes a pattern and flags as separate arguments, `RustRegex` only\naccepts a single pattern string. While it doesn't support separate flags, you can use inline flags within the pattern itself.\nFor more details about Rust's regex syntax and capabilities, check out the [Rust regex documentation][rust regex].\nNEWPARAGRAPH\n- **Regex Limitations** — Only a subset of the Regex engine is actually\nsupported. This is due to certain features like lookahead and lookaround assertions\nnot feasible to use in an LR(1) grammar, as well as certain flags being unnecessary\nfor tree-sitter. However, plenty of features are supported by default:\nNEWPARAGRAPH\n  - Character classes\n  - Character ranges\n  - Character sets\n  - Quantifiers\n  - Alternation\n  - Grouping\n  - Unicode character escapes\n  - Unicode property escapes\nNEWPARAGRAPH\n- **Sequences : `seq(rule1, rule2, ...)`** — This function creates a rule that matches any number of other rules, one after\nanother. It is analogous to simply writing multiple symbols next to each other in [EBNF notation][ebnf].\nNEWPARAGRAPH\n- **Alternatives : `choice(rule1, rule2, ...)`** — This function creates a rule that matches *one* of a set of possible\nrules. The order of the arguments does not matter. This is analogous to the `|` (pipe) operator in EBNF notation.\nNEWPARAGRAPH\n- **Repetitions : `repeat(rule)`** — This function creates a rule that matches *zero-or-more* occurrences of a given rule.\nIt is analogous to the `{x}` (curly brace) syntax in EBNF notation.\nNEWPARAGRAPH\n- **Repetitions : `repeat1(rule)`** — This function creates a rule that matches *one-or-more* occurrences of a given rule.\nThe previous `repeat` rule is implemented in `repeat1` but is included because it is very commonly used.\nNEWPARAGRAPH\n- **Options : `optional(rule)`** — This function creates a rule that matches *zero or one* occurrence of a given rule.\nIt is analogous to the `[x]` (square bracket) syntax in EBNF notation.\nNEWPARAGRAPH\n- **Precedence : `prec(number, rule)`** — This function marks the given rule with a numerical precedence, which will be used\nto resolve [*LR(1) Conflicts*][lr-conflict] at parser-generation time. When two rules overlap in a way that represents either\na true ambiguity or a *local* ambiguity given one token of lookahead, Tree-sitter will try to resolve the conflict by matching\nthe rule with the higher precedence. The default precedence of all rules is zero. This works similarly to the\n[precedence directives][yacc-prec] in Yacc grammars.\nNEWPARAGRAPH\n  This function can also be used to assign lexical precedence to a given\n  token, but it must be wrapped in a `token` call, such as `token(prec(1, 'foo'))`. This reads as \"the token `foo` has a\n  lexical precedence of 1\". The purpose of lexical precedence is to solve the issue where multiple tokens can match the same\n  set of characters, but one token should be preferred over the other. See [Lexical Precedence vs Parse Precedence][lexical vs parse]\n  for a more detailed explanation.\nNEWPARAGRAPH\n- **Left Associativity : `prec.left([number], rule)`** — This function marks the given rule as left-associative (and optionally\napplies a numerical precedence). When an LR(1) conflict arises in which all the rules have the same numerical precedence,\nTree-sitter will consult the rules' associativity. If there is a left-associative rule, Tree-sitter will prefer matching\na rule that ends *earlier*. This works similarly to [associativity directives][yacc-prec] in Yacc grammars.\nNEWPARAGRAPH\n- **Right Associativity : `prec.right([number], rule)`** — This function is like `prec.left`, but it instructs Tree-sitter\nto prefer matching a rule that ends *later*.\nNEWPARAGRAPH\n- **Dynamic Precedence : `prec.dynamic(number, rule)`** — This function is similar to `prec`, but the given numerical precedence\nis applied at *runtime* instead of at parser generation time. This is only necessary when handling a conflict dynamically\nusing the `conflicts` field in the grammar, and when there is a genuine *ambiguity*: multiple rules correctly match a given\npiece of code. In that event, Tree-sitter compares the total dynamic precedence associated with each rule, and selects the\none with the highest total. This is similar to [dynamic precedence directives][bison-dprec] in Bison grammars.\nNEWPARAGRAPH\n- **Tokens : `token(rule)`** — This function marks the given rule as producing only\na single token. Tree-sitter's default is to treat each String or RegExp literal\nin the grammar as a separate token. Each token is matched separately by the lexer\nand returned as its own leaf node in the tree. The `token` function allows you to\nexpress a complex rule using the functions described above (rather than as a single\nregular expression) but still have Tree-sitter treat it as a single token.\nThe token function will only accept terminal rules, so `token($.foo)` will not work.\nYou can think of it as a shortcut for squashing complex rules of strings or regexes\ndown to a single token.\nNEWPARAGRAPH\n- **Immediate Tokens : `token.immediate(rule)`** — Usually, whitespace (and any other extras, such as comments) is optional\nbefore each token. This function means that the token will only match if there is no whitespace.\nNEWPARAGRAPH\n- **Aliases : `alias(rule, name)`** — This function causes the given rule to *appear* with an alternative name in the syntax\ntree. If `name` is a *symbol*, as in `alias($.foo, $.bar)`, then the aliased rule will *appear* as a [named node][named-vs-anonymous-nodes]\ncalled `bar`. And if `name` is a *string literal*, as in `alias($.foo, 'bar')`, then the aliased rule will appear as an\n[anonymous node][named-vs-anonymous-nodes], as if the rule had been written as the simple string.\nNEWPARAGRAPH\n- **Field Names : `field(name, rule)`** — This function assigns a *field name* to the child node(s) matched by the given\nrule. In the resulting syntax tree, you can then use that field name to access specific children.\nNEWPARAGRAPH\n- **Reserved Keywords : `reserved(wordset, rule)`**  — This function will override the global reserved word set with the\none passed into the `wordset` parameter. This is useful for contextual keywords, such as `if` in JavaScript, which cannot\nbe used as a variable name in most contexts, but can be used as a property name.\nNEWPARAGRAPH\nIn addition to the `name` and `rules` fields, grammars have a few other optional public fields that influence the behavior\nof the parser. Each of these fields is a function that accepts the grammar object (`$`) as its only parameter, like the\ngrammar rules themselves. These fields are:\nNEWPARAGRAPH\n- **`extras`** — an array of tokens that may appear *anywhere* in the language. This is often used for whitespace and\ncomments. The default value of `extras` is to accept whitespace. To control whitespace explicitly, specify\n`extras: $ => []` in your grammar.\nNEWPARAGRAPH\n- **`inline`** — an array of rule names that should be automatically *removed* from the grammar by replacing all of their\nusages with a copy of their definition. This is useful for rules that are used in multiple places but for which you *don't*\nwant to create syntax tree nodes at runtime.\nNEWPARAGRAPH\n- **`conflicts`** — an array of arrays of rule names. Each inner array represents a set of rules that's involved in an\n*LR(1) conflict* that is *intended to exist* in the grammar. When these conflicts occur at runtime, Tree-sitter will use\nthe GLR algorithm to explore all the possible interpretations. If *multiple* parses end up succeeding, Tree-sitter will pick\nthe subtree whose corresponding rule has the highest total *dynamic precedence*.\nNEWPARAGRAPH\n- **`externals`** — an array of token names which can be returned by an\n[*external scanner*][external-scanners]. External scanners allow you to write custom C code which runs during the lexing\nprocess to handle lexical rules (e.g. Python's indentation tokens) that cannot be described by regular expressions.\nNEWPARAGRAPH\n- **`precedences`** — an array of arrays of strings, where each array of strings defines named precedence levels in descending\norder. These names can be used in the `prec` functions to define precedence relative only to other names in the array, rather\nthan globally. Can only be used with parse precedence, not lexical precedence.\nNEWPARAGRAPH\n- **`word`** — the name of a token that will match keywords to the\n[keyword extraction][keyword-extraction] optimization.\nNEWPARAGRAPH\n- **`supertypes`** — an array of hidden rule names which should be considered to be 'supertypes' in the generated\n[*node types* file][static-node-types].\nNEWPARAGRAPH\n- **`reserved`** — similar in structure to the main `rules` property, an object of reserved word sets associated with an\narray of reserved rules. The reserved rule in the array must be a terminal token meaning it must be a string, regex, or token,\nor a terminal rule. The *first* reserved word set in the object is the global word set, meaning it applies to every rule\nin every parse state. However, certain keywords are contextual, depending on the rule. For example, in JavaScript, keywords\nare typically not allowed as ordinary variables, however, they *can* be used as a property name. In this situation, the `reserved`\nfunction would be used, and the word set to pass in would be the name of the word set that is declared in the `reserved`\nobject that corresponds to an empty array, signifying *no* keywords are reserved.\nNEWPARAGRAPH\n[bison-dprec]: https://www.gnu.org/software/bison/manual/html_node/Generalized-LR-Parsing.html\n[ebnf]: https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form\n[external-scanners]: ./4-external-scanners.md\n[keyword-extraction]: ./3-writing-the-grammar.md"],"code_blocks":["\nnew RustRegex('(?i)[a-z_][a-z0-9_]*') // matches a simple identifier\n"]},{"file_path":"tree-sitter/docs/src/creating-parsers/2-the-grammar-dsl.md","header":"keyword-extraction","text_blocks":["[lexical vs parse]: ./3-writing-the-grammar.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/2-the-grammar-dsl.md","header":"lexical-precedence-vs-parse-precedence","text_blocks":["[lr-conflict]: https://en.wikipedia.org/wiki/LR_parser"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/2-the-grammar-dsl.md","header":"Conflicts_in_the_constructed_tables","text_blocks":["[named-vs-anonymous-nodes]: ../using-parsers/2-basic-parsing.md"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/2-the-grammar-dsl.md","header":"named-vs-anonymous-nodes","text_blocks":["[rust regex]: https://docs.rs/regex/1.1.8/regex/"],"code_blocks":[]},{"file_path":"tree-sitter/docs/src/creating-parsers/2-the-grammar-dsl.md","header":"grouping-and-flags","text_blocks":["[static-node-types]: ../using-parsers/6-static-node-types.md\n[yacc-prec]: https://docs.oracle.com/cd/E19504-01/802-5880/6i9k05dh3/index.html"],"code_blocks":[]}]